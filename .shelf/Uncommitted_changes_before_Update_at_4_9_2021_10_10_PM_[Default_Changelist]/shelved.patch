Index: src/main/resources/mixins.client.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\r\n  \"required\": true,\r\n  \"compatibilityLevel\": \"JAVA_8\",\r\n  \"package\": \"client.mixin.mixins\",\r\n  \"refmap\": \"mixins.client.refmap.json\",\r\n  \"mixins\": [\r\n    \"AccessorSPacketPlayerPosLook\",\r\n    \"IPlayerControllerMP\",\r\n    \"MixinClientPlayer\",\r\n    \"MixinContainerPlayer\",\r\n    \"MixinEntityPlayer\",\r\n    \"MixinEntityPlayerSP\",\r\n    \"MixinGuiNewChat\",\r\n    \"MixinGuiScreen\",\r\n    \"MixinItemRenderer\",\r\n    \"MixinKey\",\r\n    \"MixinLiquidBlock\",\r\n    \"MixinMinecraft\",\r\n    \"MixinNetworkManager\",\r\n    \"MixinPlayerControllerMP\",\r\n    \"MixinRenderArmor\",\r\n    \"MixinRenderGlobal\",\r\n    \"MixinRenderLivingBase\",\r\n    \"MixinRenderModifiedCrystal\",\r\n    \"MixinRenderPlayer\",\r\n    \"MixinTabOverlay\",\r\n    \"MixinWorld\"\r\n  ]\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/resources/mixins.client.json b/src/main/resources/mixins.client.json
--- a/src/main/resources/mixins.client.json	(revision fd8ceada98ccf0de6df46462516f7fec90e96845)
+++ b/src/main/resources/mixins.client.json	(date 1630759305457)
@@ -4,18 +4,14 @@
   "package": "client.mixin.mixins",
   "refmap": "mixins.client.refmap.json",
   "mixins": [
+    "MixinMinecraft",
     "AccessorSPacketPlayerPosLook",
     "IPlayerControllerMP",
-    "MixinClientPlayer",
     "MixinContainerPlayer",
-    "MixinEntityPlayer",
-    "MixinEntityPlayerSP",
     "MixinGuiNewChat",
-    "MixinGuiScreen",
     "MixinItemRenderer",
     "MixinKey",
     "MixinLiquidBlock",
-    "MixinMinecraft",
     "MixinNetworkManager",
     "MixinPlayerControllerMP",
     "MixinRenderArmor",
@@ -24,6 +20,10 @@
     "MixinRenderModifiedCrystal",
     "MixinRenderPlayer",
     "MixinTabOverlay",
+    "MixinGuiScreen",
+    "MixinEntityPlayerSP",
+    "MixinEntityPlayer",
+    "MixinClientPlayer",
     "MixinWorld"
   ]
 }
Index: src/main/java/client/modules/combat/AutoCrystal.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package client.modules.combat;\r\n\r\nimport client.events.PacketEvent;\r\nimport client.events.Render3DEvent;\r\nimport client.modules.Module;\r\nimport client.modules.client.ClickGui;\r\nimport client.gui.impl.setting.Setting;\r\nimport client.util.Timer;\r\nimport client.util.*;\r\nimport net.minecraft.entity.Entity;\r\nimport net.minecraft.entity.item.EntityEnderCrystal;\r\nimport net.minecraft.entity.player.EntityPlayer;\r\nimport net.minecraft.init.Items;\r\nimport net.minecraft.init.SoundEvents;\r\nimport net.minecraft.item.ItemEndCrystal;\r\nimport net.minecraft.network.play.client.CPacketHeldItemChange;\r\nimport net.minecraft.network.play.client.CPacketPlayerTryUseItemOnBlock;\r\nimport net.minecraft.network.play.client.CPacketUseEntity;\r\nimport net.minecraft.network.play.server.SPacketSoundEffect;\r\nimport net.minecraft.network.play.server.SPacketSpawnObject;\r\nimport net.minecraft.util.EnumFacing;\r\nimport net.minecraft.util.EnumHand;\r\nimport net.minecraft.util.SoundCategory;\r\nimport net.minecraft.util.math.AxisAlignedBB;\r\nimport net.minecraft.util.math.BlockPos;\r\nimport net.minecraftforge.fml.common.eventhandler.SubscribeEvent;\r\n\r\nimport java.awt.*;\r\nimport java.util.List;\r\nimport java.util.*;\r\n\r\npublic class AutoCrystal extends Module {\r\n    public Setting<Settings> setting;\r\n    public enum Settings{AUTOCRYSTAL, RENDER}\r\n    public Setting<SpeedFactor> speedFactor;\r\n    public enum SpeedFactor {TICK, UPDATE}\r\n    public Setting<CalcMode> calcMode;\r\n    public enum CalcMode{NORMAL, AUTO}\r\n    public Setting<Boolean> doBreak;\r\n    public Setting<Boolean> doPlace;\r\n    public Setting<Float> targetRange;\r\n    public Setting<Boolean> cancel;\r\n    public Setting<Float> breakRange;\r\n    public Setting<Float> breakWallRange;\r\n    public Setting<Integer> breakDelay;\r\n    public Setting<Boolean> instant;\r\n    public Setting<Float> placeRange;\r\n    public Setting<Float> placeRangeWall;\r\n    public Setting<Integer> armorPercent;\r\n    public Setting<Float> facePlaceHP;\r\n    public Setting<Float> minDamage;\r\n    public Setting<Float> maxSelfDamage;\r\n    public Setting<Boolean> swing;\r\n    public Setting<Boolean> announceOnly;\r\n    public Setting<Boolean> text;\r\n    public Setting<Boolean> box;\r\n    public Setting<RenderMode> renderMode;\r\n    public enum RenderMode{NORMAL, FADE, GLIDE}\r\n    public Setting<Float> accel;\r\n    public Setting<Float> moveSpeed;\r\n    public Setting<Enum> fade;\r\n    public enum Enum{FAST, MEDIUM, SLOW}\r\n    public Setting<Integer> red;\r\n    public Setting<Integer> green;\r\n    public Setting<Integer> blue;\r\n    public Setting<Integer> alpha;\r\n    public Setting<Boolean> rainbow;\r\n    public Setting<Boolean> outline;\r\n    public Setting<Integer> cRed;\r\n    public Setting<Integer> cGreen;\r\n    public Setting<Integer> cBlue;\r\n    public Setting<Integer> cAlpha;\r\n    public Setting<Integer> lineWidth;\r\n    public Setting<Boolean> cRainbow;\r\n    public Setting<Boolean> silentSwitch;\r\n    public Set<BlockPos> placeSet;\r\n    public  BlockPos placePos = null;\r\n    public Timer clearTimer;\r\n    public Timer breakTimer;\r\n    public int predictedId;\r\n    public BlockPos renderPos;\r\n    public BlockPos pos2;\r\n    public EntityPlayer target;\r\n    public boolean offhand;\r\n    public boolean mainhand;\r\n    public static AutoCrystal INSTANCE;\r\n    private final ArrayList<RenderPos> renderMap = new ArrayList<>();\r\n    private final ArrayList<BlockPos> currentTargets = new ArrayList<>();\r\n    private BlockPos lastRenderPos;\r\n    private AxisAlignedBB renderBB;\r\n    private float timePassed;\r\n\r\n    public AutoCrystal() {\r\n        super(\"AutoCrystal\", \"Automatically places/breaks crystals to deal damage to opponents.\", Category.COMBAT);\r\n        this.setting = (Setting<Settings>)this.register(new Setting<>(\"Setting\", Settings.AUTOCRYSTAL));\r\n        this.speedFactor = (Setting<SpeedFactor>)this.register(new Setting<>(\"SpeedFactor\", SpeedFactor.UPDATE, v-> setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.calcMode = (Setting<CalcMode>)this.register(new Setting<>(\"CalcMode\", CalcMode.NORMAL, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.doPlace = (Setting<Boolean>)this.register(new Setting(\"Place\", true, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.doBreak = (Setting<Boolean>)this.register(new Setting(\"Break\", true, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.breakRange = (Setting<Float>)this.register(new Setting(\"BreakRange\", 5.0f, 1.0f, 6.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.placeRange = (Setting<Float>)this.register(new Setting(\"PlaceRange\", 5.0f, 1.0f, 6.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.targetRange = (Setting<Float>)this.register(new Setting(\"TargetRange\",9.0f, 1.0f, 15.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.breakWallRange = (Setting<Float>)this.register(new Setting(\"BreakRangeWall\", 5.0f, 1.0f, 6.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.placeRangeWall = (Setting<Float>)this.register(new Setting(\"PlaceRangeWall\", 5.0f, 1.0f, 6.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.breakDelay = (Setting<Integer>)this.register(new Setting(\"BreakDelay\", 0, 0, 200, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.instant = (Setting<Boolean>)this.register(new Setting(\"Predict\", false, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.cancel = (Setting<Boolean>)this.register(new Setting(\"Cancel\", true, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.armorPercent = (Setting<Integer>)this.register(new Setting(\"Armor%\", 10, 0, 100, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.facePlaceHP = (Setting<Float>)this.register(new Setting(\"FaceplaceHP\", 8.0f, 0.0f, 36.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.minDamage = (Setting<Float>)this.register(new Setting(\"MinDamage\", 4.0f, 1.0f, 36.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.maxSelfDamage = (Setting<Float>)this.register(new Setting(\"MaxSelfDmg\",8.0f, 1.0f, 36.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.silentSwitch = (Setting<Boolean>)this.register(new Setting(\"MaxSelfDmg\",true, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.swing = (Setting<Boolean>)this.register(new Setting(\"Swing\", false, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.announceOnly = (Setting<Boolean>)this.register(new Setting(\"AnnounceOnly\", false, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.renderMode = (Setting<RenderMode>)this.register(new Setting<>(\"RenderMode\", RenderMode.NORMAL, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.box = (Setting<Boolean>)this.register(new Setting<>(\"Box\", true, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.fade = (Setting<Enum>)this.register(new Setting<>(\"Fade\", Enum.FAST, v-> this.setting.getCurrentState() == Settings.RENDER && renderMode.getCurrentState() == RenderMode.FADE));\r\n        this.accel = (Setting<Float>) this.register(new Setting<>(\"Deceleration\" , 0.8f , 0.0f, 1.0f, v-> this.setting.getCurrentState() == Settings.RENDER && renderMode.getCurrentState() == RenderMode.GLIDE));\r\n        this.moveSpeed = (Setting<Float>) this.register(new Setting<>(\"Speed\" , 900.0f , 0.0f, 1500.0f, v-> this.setting.getCurrentState() == Settings.RENDER && renderMode.getCurrentState() == RenderMode.GLIDE));\r\n        this.red = (Setting<Integer>)this.register(new Setting<>(\"BoxRed\", 255, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.green = (Setting<Integer>)this.register(new Setting<>(\"BoxGreen\", 255, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.blue = (Setting<Integer>)this.register(new Setting<>(\"BoxBlue\", 255, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.alpha = (Setting<Integer>)this.register(new Setting<>(\"BoxAlpha\", 120, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.rainbow = (Setting<Boolean>)this.register(new Setting<>(\"BoxRainbow\", true, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.outline = (Setting<Boolean>)this.register(new Setting<>(\"Outline\", true, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.cRed = (Setting<Integer>)this.register(new Setting<>(\"OutlineRed\", 255, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.cGreen = (Setting<Integer>)this.register(new Setting<>(\"OutlineGreen\", 255, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.cBlue = (Setting<Integer>)this.register(new Setting<>(\"OutlineBlue\", 255, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.cAlpha = (Setting<Integer>)this.register(new Setting<>(\"OutlineAlpha\", 255, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.lineWidth = (Setting<Integer>)this.register(new Setting<>(\"OutlineWidth\", 1, 0, 5, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.cRainbow = (Setting<Boolean>)this.register(new Setting<>(\"OutlineRainbow\", true, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.placeSet = new HashSet<>();\r\n        this.clearTimer = new Timer();\r\n        this.breakTimer = new Timer();\r\n        this.predictedId = -1;\r\n        this.renderPos = null;\r\n        this.pos2 = null;\r\n        this.target = null;\r\n        AutoCrystal.INSTANCE = this;\r\n    }\r\n\r\n    public static AutoCrystal getInstance() {\r\n        return AutoCrystal.INSTANCE;\r\n    }\r\n\r\n    private boolean update() {\r\n        if (fullNullCheck()) {\r\n            return false;\r\n        }\r\n        if (this.clearTimer.hasReached(500L)) {\r\n            this.placeSet.clear();\r\n            this.predictedId = -1;\r\n            this.renderPos = null;\r\n            this.clearTimer.reset();\r\n        }\r\n        this.offhand = (mc.player.getHeldItemOffhand().getItem() == Items.END_CRYSTAL);\r\n        this.mainhand = (mc.player.getHeldItemMainhand().getItem() == Items.END_CRYSTAL);\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void onToggle() {\r\n        this.placeSet.clear();\r\n        this.predictedId = -1;\r\n        this.renderPos = null;\r\n    }\r\n\r\n    @Override\r\n    public void onUpdate() {\r\n        if (!this.update()) {\r\n            return;\r\n        }\r\n        this.target = EntityUtil.getTarget(this.targetRange.getCurrentState());\r\n        if (this.target == null) {\r\n            return;\r\n        }\r\n        if (speedFactor.getCurrentState() == SpeedFactor.UPDATE && !announceOnly.getCurrentState()) {\r\n            if(doPlace.getCurrentState()) {\r\n                this.doPlace();\r\n            }\r\n            if(doBreak.getCurrentState()) {\r\n                this.doBreak();\r\n            }\r\n        }\r\n    }\r\n    public void onDisable(){\r\n        this.lastRenderPos = null;\r\n    }\r\n    @Override\r\n    public void onTick() {\r\n        if (speedFactor.getCurrentState() == SpeedFactor.TICK && !announceOnly.getCurrentState()) {\r\n            if(doPlace.getCurrentState()) {\r\n                this.doPlace();\r\n            }\r\n            if(doBreak.getCurrentState()) {\r\n                this.doBreak();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private void doPlace() {\r\n        float maxDamage = 0.5f;\r\n        final List<BlockPos> sphere = BlockUtil.getSphere(this.placeRange.getCurrentState(), true);\r\n        for (int size = sphere.size(), i = 0; i < size; ++i) {\r\n            final BlockPos pos = sphere.get(i);\r\n            final float self = this.calculate(pos, mc.player);\r\n            if (BlockUtil.canPlaceCrystal(pos, true)) {\r\n                final float damage;\r\n                if (calcMode.getCurrentState() == CalcMode.NORMAL) {\r\n                    if (EntityUtil.getHealth(mc.player) > self + 0.5f && this.maxSelfDamage.getCurrentState() > self && (damage = this.calculate(pos, this.target)) > maxDamage && damage > self) {\r\n                        if (damage <= this.minDamage.getCurrentState()) {\r\n                            if (this.facePlaceHP.getCurrentState() <= EntityUtil.getHealth(this.target) && !PlayerUtil.isArmorLow(this.target, this.armorPercent.getCurrentState())) {\r\n                                continue;\r\n                            }\r\n                            if (damage <= 2.0f) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        maxDamage = damage;\r\n                        placePos = pos;\r\n                        pos2 = placePos;\r\n                        currentTargets.clear();\r\n                        currentTargets.add(pos);\r\n                    }\r\n                } else if (calcMode.getCurrentState() == CalcMode.AUTO) {\r\n                    if ((damage = this.calculate(pos, this.target)) > self && damage > minDamage.getCurrentState() && self < maxSelfDamage.getCurrentState()) {\r\n                        if (damage <= this.minDamage.getCurrentState()) {\r\n                            if (this.facePlaceHP.getCurrentState() <= EntityUtil.getHealth(this.target) && !PlayerUtil.isArmorLow(this.target, this.armorPercent.getCurrentState())) {\r\n                                continue;\r\n                            }\r\n                            if (damage <= 2.0f) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        maxDamage = damage;\r\n                        placePos = pos;\r\n                        pos2 = placePos;\r\n                        currentTargets.clear();\r\n                        currentTargets.add(pos);\r\n                    }\r\n                } {\r\n\r\n                }\r\n            }\r\n\r\n        }\r\n        if (!this.offhand && !this.mainhand) {\r\n            this.renderPos = null;\r\n            return;\r\n        }\r\n        if (placePos != null && silentSwitch.getCurrentState()) {\r\n            mc.player.connection.sendPacket(new CPacketHeldItemChange(InventoryUtil.findHotbarBlock(ItemEndCrystal.class)));\r\n        }\r\n        if (placePos != null) {\r\n            clearMap(placePos);\r\n            Objects.requireNonNull(mc.getConnection()).sendPacket(new CPacketPlayerTryUseItemOnBlock(placePos, EnumFacing.UP, this.offhand ? EnumHand.OFF_HAND : EnumHand.MAIN_HAND , 0.5f, 0.5f, 0.5f));\r\n            renderMap.add(new RenderPos(placePos, 0.0));\r\n            this.placeSet.add(placePos);\r\n            this.renderPos = placePos;\r\n        } else {\r\n            this.renderPos = null;\r\n        }\r\n        if (silentSwitch.getCurrentState()) {\r\n            int oldSlot = mc.player.inventory.currentItem;\r\n            mc.player.connection.sendPacket(new CPacketHeldItemChange(oldSlot));\r\n        }\r\n    }\r\n\r\n    private void doBreak() {\r\n        Entity entity = null;\r\n        for (int size = mc.world.loadedEntityList.size(), i = 0; i < size; ++i) {\r\n            final Entity crystal = mc.world.loadedEntityList.get(i);\r\n            if (crystal.getClass() == EntityEnderCrystal.class && this.isValid(crystal)) {\r\n                if (crystal.getEntityId() != this.predictedId) {\r\n                    final float self = this.calculate(crystal, mc.player);\r\n                    final float damage;\r\n                    if (EntityUtil.getHealth(mc.player) > self + 0.5f && (damage = this.calculate(crystal, this.target)) > self && damage > self) {\r\n                        if (damage <= this.minDamage.getCurrentState()) {\r\n                            if (this.facePlaceHP.getCurrentState() <= EntityUtil.getHealth(this.target) && !PlayerUtil.isArmorLow(this.target, this.armorPercent.getCurrentState())) {\r\n                                continue;\r\n                            }\r\n                            if (damage <= 2.0f) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        entity = crystal;\r\n                    }\r\n                }\r\n            }\r\n            if (entity != null && this.breakTimer.passedMs(this.breakDelay.getCurrentState())) {\r\n                BlockPos renderPos = entity.getPosition().down();\r\n                clearMap(renderPos);\r\n                Objects.requireNonNull(mc.getConnection()).sendPacket(new CPacketUseEntity(entity));\r\n                renderMap.add(new RenderPos(renderPos, 0.0));\r\n                if(swing.getCurrentState()) {\r\n                    mc.player.swingArm(this.offhand ? EnumHand.OFF_HAND : EnumHand.MAIN_HAND);\r\n                }\r\n                this.breakTimer.reset();\r\n            }\r\n        }\r\n    }\r\n\r\n    private boolean isValid(final Entity crystal) {\r\n        return (mc.player.canEntityBeSeen(crystal) ? (this.breakRange.getCurrentState() * this.breakRange.getCurrentState()) : (this.breakWallRange.getCurrentState() * this.breakWallRange.getCurrentState())) > mc.player.getDistanceSq(crystal);\r\n    }\r\n\r\n    private float calculate(final Entity crystal, final EntityPlayer target) {\r\n        return EntityUtil.calculate(crystal.posX, crystal.posY, crystal.posZ, target);\r\n    }\r\n\r\n    private float calculate(final BlockPos pos, final EntityPlayer entity) {\r\n        return EntityUtil.calculate(pos.getX() + 0.5f, pos.getY() + 1, pos.getZ() + 0.5f, entity);\r\n    }\r\n\r\n    public void instantHit(final int id) {\r\n        final CPacketUseEntity hitPacket = new CPacketUseEntity();\r\n        hitPacket.entityId = id;\r\n        hitPacket.action = CPacketUseEntity.Action.ATTACK;\r\n        Objects.requireNonNull(mc.getConnection()).sendPacket(hitPacket);\r\n        this.predictedId = id;\r\n        if(swing.getCurrentState()) {\r\n            mc.player.swingArm(this.offhand ? EnumHand.OFF_HAND : EnumHand.MAIN_HAND);\r\n        }\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public void onPacketReceive(final PacketEvent.Receive event) {\r\n        if (event.getPacket() instanceof SPacketSpawnObject && this.instant.getCurrentState()) {\r\n            final Object packet = event.getPacket();\r\n            final BlockPos pos = new BlockPos(((SPacketSpawnObject)packet).getX(), ((SPacketSpawnObject)packet).getY(), ((SPacketSpawnObject)packet).getZ());\r\n            if (((SPacketSpawnObject)packet).getType() == 51 && this.placeSet.contains(pos.down())) {\r\n                if (mc.player.getDistance(pos.getX(), pos.getY(), pos.getZ()) > this.breakRange.getCurrentState()) {\r\n                    return;\r\n                }\r\n                this.instantHit(((SPacketSpawnObject)packet).getEntityID());\r\n            }\r\n        }\r\n        Object packet;\r\n        if (event.getPacket() instanceof SPacketSoundEffect && this.cancel.getCurrentState() && ((SPacketSoundEffect)(packet = event.getPacket())).getCategory() == SoundCategory.BLOCKS && ((SPacketSoundEffect)packet).getSound() == SoundEvents.ENTITY_GENERIC_EXPLODE) {\r\n            final ArrayList<Entity> entities = new ArrayList<>(mc.world.loadedEntityList);\r\n            for (int size = entities.size(), i = 0; i < size; ++i) {\r\n                final Entity entity = entities.get(i);\r\n                if (entity instanceof EntityEnderCrystal) {\r\n                    if (entity.getDistanceSq(((SPacketSoundEffect)packet).getX(), ((SPacketSoundEffect)packet).getY(), ((SPacketSoundEffect)packet).getZ()) < 36.0) {\r\n                        entity.setDead();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onRender3D(Render3DEvent event) {\r\n\r\n        if (renderMap.isEmpty()) return;\r\n        List<RenderPos> toRemove = new ArrayList<>();\r\n        for (Iterator<RenderPos> it = renderMap.iterator(); it.hasNext(); ) {\r\n            RenderPos renderPos = it.next();\r\n            Color color;\r\n            Color color2;\r\n            color = new Color(red.getCurrentState(), green.getCurrentState(), blue.getCurrentState(), (int) Math.max(alpha.getCurrentState() - renderPos.alpha, 0));\r\n            color2 = new Color(cRed.getCurrentState(), cGreen.getCurrentState(), cBlue.getCurrentState(), (int) Math.max(cAlpha.getCurrentState() - renderPos.alpha, 0));\r\n            if(renderMode.getCurrentState() == RenderMode.NORMAL || renderMode.getCurrentState() == RenderMode.FADE) {\r\n                RenderUtil.drawBoxESP(renderPos.pos, rainbow.getCurrentState() ? ColorUtil.rainbow(ClickGui.getInstance().rainbowHue.getCurrentState()) : color, this.outline.getCurrentState(), cRainbow.getCurrentState() ? ColorUtil.rainbow(ClickGui.getInstance().rainbowHue.getCurrentState()) : color2, this.lineWidth.getCurrentState(), this.outline.getCurrentState(), this.box.getCurrentState(), (int) Math.max(cAlpha.getCurrentState() - renderPos.alpha, 0), true);\r\n            }\r\n            if (renderPos.alpha > Math.max(alpha.getCurrentState(), rainbow.getCurrentState() ? ColorUtil.rainbow(ClickGui.getInstance().rainbowHue.getCurrentState()).getRGB() : ColorUtil.toRGBA(red.getCurrentState(), green.getCurrentState(), blue.getCurrentState())))\r\n                toRemove.add(renderPos);\r\n            renderPos.alpha = renderPos.alpha + (fade.getCurrentState() == Enum.FAST ? 1.5 : fade.getCurrentState() == Enum.SLOW ? 0.5 : 1);\r\n            if (currentTargets.contains(renderPos.pos)) {\r\n                renderPos.alpha = 0;\r\n            } else if (renderMode.getCurrentState() != RenderMode.FADE) {\r\n                toRemove.add(renderPos);\r\n            }\r\n        }\r\n        renderMap.removeAll(toRemove);\r\n\r\n        if (renderMode.getCurrentState() == RenderMode.GLIDE && renderPos != null) {\r\n            Color color2 = new Color(cRed.getCurrentState(), cGreen.getCurrentState(), cBlue.getCurrentState(), cAlpha.getCurrentState());\r\n            Color color = new Color(red.getCurrentState(), green.getCurrentState(), blue.getCurrentState(), alpha.getCurrentState());\r\n            if ( this.lastRenderPos == null || AutoCrystal.mc.player.getDistance (this.renderBB.minX , this.renderBB.minY , this.renderBB.minZ ) > this.placeRange.getCurrentState() ) {\r\n                this.lastRenderPos = this.renderPos;\r\n                this.renderBB = new AxisAlignedBB( this.renderPos );\r\n                this.timePassed = 0;\r\n            }\r\n            if ( !this.lastRenderPos.equals ( this.renderPos ) ) {\r\n                this.lastRenderPos = this.renderPos;\r\n                this.timePassed = 0;\r\n            }\r\n            double xDiff = this.renderPos.getX ( ) - this.renderBB.minX;\r\n            double yDiff = this.renderPos.getY ( ) - this.renderBB.minY;\r\n            double zDiff = this.renderPos.getZ ( ) - this.renderBB.minZ;\r\n            float multiplier = this.timePassed / this.moveSpeed.getCurrentState ( ) * this.accel.getCurrentState ( );\r\n            if ( multiplier > 1 ) multiplier = 1;\r\n            this.renderBB = this.renderBB.offset ( xDiff * multiplier , yDiff * multiplier , zDiff * multiplier );\r\n                RenderUtil.drawPerryESP(this.renderBB, color, color2, lineWidth.getCurrentState(), outline.getCurrentState(), box.getCurrentState(), 1.0f, 1.0f, 1.0f);\r\n            if ( this.renderBB.equals ( new AxisAlignedBB ( this.renderPos ) ) ) {\r\n                this.timePassed = 0;\r\n            } else this.timePassed += 50.0f;\r\n        }\r\n\r\n    }\r\n    static {\r\n        AutoCrystal.INSTANCE = new AutoCrystal();\r\n    }\r\n\r\n\r\n\r\n    class RenderPos {\r\n        public RenderPos(BlockPos pos, Double damage) {\r\n            this.pos = pos;\r\n            this.damage = damage;\r\n        }\r\n\r\n        Double damage;\r\n        double alpha;\r\n        BlockPos pos;\r\n    }\r\n\r\n    private void clearMap(BlockPos checkBlock) {\r\n        List<RenderPos> toRemove = new ArrayList<>();\r\n        if (checkBlock == null || renderMap.isEmpty()) return;\r\n        for (RenderPos pos : renderMap) {\r\n            if (pos.pos.getX() == checkBlock.getX() && pos.pos.getY() == checkBlock.getY() && pos.pos.getZ() == checkBlock.getZ())\r\n                toRemove.add(pos);\r\n        }\r\n        renderMap.removeAll(toRemove);\r\n    }\r\n\r\n    public String hudInfoString() {\r\n        if(target != null) {\r\n            return target.getName() + \" | \" + Math.round(target.getHealth());\r\n        }\r\n        return null;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/client/modules/combat/AutoCrystal.java b/src/main/java/client/modules/combat/AutoCrystal.java
--- a/src/main/java/client/modules/combat/AutoCrystal.java	(revision fd8ceada98ccf0de6df46462516f7fec90e96845)
+++ b/src/main/java/client/modules/combat/AutoCrystal.java	(date 1630764546084)
@@ -245,13 +245,15 @@
             }
 
         }
+        if (placePos != null && silentSwitch.getCurrentState()) {
+            mc.player.connection.sendPacket(new CPacketHeldItemChange(InventoryUtil.findHotbarBlock(ItemEndCrystal.class)));
+        }
+
         if (!this.offhand && !this.mainhand) {
             this.renderPos = null;
             return;
         }
-        if (placePos != null && silentSwitch.getCurrentState()) {
-            mc.player.connection.sendPacket(new CPacketHeldItemChange(InventoryUtil.findHotbarBlock(ItemEndCrystal.class)));
-        }
+
         if (placePos != null) {
             clearMap(placePos);
             Objects.requireNonNull(mc.getConnection()).sendPacket(new CPacketPlayerTryUseItemOnBlock(placePos, EnumFacing.UP, this.offhand ? EnumHand.OFF_HAND : EnumHand.MAIN_HAND , 0.5f, 0.5f, 0.5f));
