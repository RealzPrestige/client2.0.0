Index: Client-2.0.0-github/Client-2.0.0/src/main/java/client/modules/combat/Holefiller.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package client.modules.combat;\r\n\r\nimport client.events.Render3DEvent;\r\nimport client.modules.Module;\r\nimport client.gui.impl.setting.Setting;\r\nimport client.util.*;\r\nimport com.google.common.eventbus.Subscribe;\r\nimport net.minecraft.block.Block;\r\nimport net.minecraft.entity.player.EntityPlayer;\r\nimport net.minecraft.init.Blocks;\r\nimport net.minecraft.item.Item;\r\nimport net.minecraft.network.play.client.CPacketHeldItemChange;\r\nimport net.minecraft.util.EnumHand;\r\nimport net.minecraft.util.math.BlockPos;\r\nimport net.minecraft.util.math.Vec3i;\r\n\r\nimport java.awt.*;\r\nimport java.util.List;\r\nimport java.util.*;\r\nimport java.util.function.ToDoubleFunction;\r\n\r\npublic class Holefiller extends Module {\r\n    public Setting<Integer> bpt;\r\n    public Setting<Float> range;\r\n    public Setting<Float> distance;\r\n    public Setting<Boolean> rotate;\r\n    public Setting<Boolean> packet;\r\n    public Setting<Boolean> render;\r\n\r\n    public Setting<Integer> red;\r\n    public Setting<Integer> green;\r\n    public Setting<Integer> blue;\r\n    public Setting<Integer> alpha;\r\n    public Setting<Integer> boxAlpha;\r\n    public Setting<Integer> lineWidth;\r\n    public Setting<Boolean> fov;\r\n    public Setting<Boolean> box;\r\n    public Setting<Boolean> outline;\r\n    public Setting<Integer> cRed;\r\n    public Setting<Integer> cGreen;\r\n    public Setting<Integer> cBlue;\r\n    public Setting<Integer> cAlpha;\r\n    private int placeAmount;\r\n    private int blockSlot;\r\n    public EntityPlayer target;\r\n    private static final BlockPos[] surroundOffset;\r\n\r\n    public Holefiller() {\r\n        super(\"HoleFiller\", \"Fills holes near enemies.\", Category.COMBAT);\r\n        bpt = (Setting<Integer>)this.register(new Setting(\"Blocks Per Tick\", 10, 1, 20));\r\n        range = (Setting<Float>)this.register(new Setting(\"Range\", 5.0f, 1.0f, 6.0f));\r\n        distance = (Setting<Float>)this.register(new Setting(\"Smart range\", 2.0f, 1.0f, 7.0f));\r\n        rotate = (Setting<Boolean>)this.register(new Setting(\"Rotate\", false));\r\n        packet = (Setting<Boolean>)this.register(new Setting(\"Packet\", true));\r\n        render = (Setting<Boolean>)this.register(new Setting(\"Render\", true));\r\n\r\n        red = (Setting<Integer>)this.register(new Setting(\"Red\", 255, 0, 255));\r\n        green = (Setting<Integer>)this.register(new Setting(\"Green\", 255, 0, 255));\r\n        blue = (Setting<Integer>)this.register(new Setting(\"Blue\", 255, 0, 255));\r\n        alpha = (Setting<Integer>)this.register(new Setting(\"Alpha\", 120, 0, 255));\r\n        boxAlpha = (Setting<Integer>)this.register(new Setting(\"BoxAlpha\", 120, 0, 255));\r\n        lineWidth = (Setting<Integer>)this.register(new Setting(\"LineWidth\", 1, 1, 5));\r\n        fov = (Setting<Boolean>)this.register(new Setting(\"inFov\", true));\r\n        box = (Setting<Boolean>)this.register(new Setting(\"Box\", true));\r\n        outline = (Setting<Boolean>)this.register(new Setting(\"Outline\", true));\r\n        cRed = (Setting<Integer>)this.register(new Setting(\"OutlineRed\", 255, 0, 255));\r\n        cGreen = (Setting<Integer>)this.register(new Setting(\"OutlineGreen\", 255, 0, 255));\r\n        cBlue = (Setting<Integer>)this.register(new Setting(\"OutlineBlue\", 255, 0, 255));\r\n        cAlpha = (Setting<Integer>)this.register(new Setting(\"OutlineAlpha\", 255, 0, 255));\r\n        placeAmount = 0;\r\n        blockSlot = -1;\r\n    }\r\n\r\n\r\n    @Subscribe\r\n    public void onUpdate() {\r\n        if (this.check()) {\r\n            final EntityPlayer currentTarget = EntityUtil.getTarget(10.0f);\r\n            target = currentTarget;\r\n            if (currentTarget == null) {\r\n                return;\r\n            }\r\n            if (EntityUtil.isInHole(currentTarget)) {\r\n                return;\r\n            }\r\n            final List<BlockPos> holes = this.calcHoles();\r\n            holes.sort(Comparator.comparingDouble((ToDoubleFunction<? super BlockPos>)currentTarget::getDistanceSq));\r\n            if (holes.size() == 0) {\r\n                return;\r\n            }\r\n            final int lastSlot = this.mc.player.inventory.currentItem;\r\n            this.blockSlot = InventoryUtil.getItemFromHotbar(Item.getItemFromBlock(Blocks.OBSIDIAN));\r\n            if (this.blockSlot == -1) {\r\n                return;\r\n            }\r\n            BlockPos hole = null;\r\n            for (final BlockPos pos : holes) {\r\n                if (currentTarget.getDistance(pos.getX(), pos.getY(), pos.getZ()) >= this.distance.getCurrentState()) {\r\n                    continue;\r\n                }\r\n                hole = pos;\r\n            }\r\n            if (hole != null) {\r\n                Objects.requireNonNull(this.mc.getConnection()).sendPacket(new CPacketHeldItemChange(this.blockSlot));\r\n                this.placeBlock(hole);\r\n                this.mc.getConnection().sendPacket(new CPacketHeldItemChange(lastSlot));\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private void placeBlock(final BlockPos pos) {\r\n        if (this.bpt.getCurrentState() > this.placeAmount) {\r\n            BlockUtil.placeBlock(pos, EnumHand.MAIN_HAND, this.rotate.getCurrentState(), this.packet.getCurrentState(), false);\r\n            ++this.placeAmount;\r\n        }\r\n    }\r\n\r\n    private boolean check() {\r\n        if (this.mc.player == null) {\r\n            return false;\r\n        }\r\n        this.placeAmount = 0;\r\n        this.blockSlot = InventoryUtil.getItemFromHotbar(Item.getItemFromBlock(Blocks.OBSIDIAN));\r\n        return true;\r\n    }\r\n\r\n    public List<BlockPos> calcHoles() {\r\n        final ArrayList<BlockPos> safeSpots = new ArrayList<>();\r\n        final List<BlockPos> positions = BlockUtil.getCock(this.range.getCurrentState(), false);\r\n        for (final BlockPos pos : positions) {\r\n            if (BlockUtil.isPositionPlaceable(pos, true) != 1 && this.mc.world.getBlockState(pos).getBlock().equals(Blocks.AIR) && this.mc.world.getBlockState(pos.add(0, 1, 0)).getBlock().equals(Blocks.AIR)) {\r\n                if (this.mc.world.getBlockState(pos.add(0, 2, 0)).getBlock().equals(Blocks.AIR)) {\r\n                    boolean isSafe = true;\r\n                    for (final BlockPos offset : Holefiller.surroundOffset) {\r\n                        final Block block = this.mc.world.getBlockState(pos.add(offset)).getBlock();\r\n                        if (block != Blocks.BEDROCK) {\r\n                            if (block != Blocks.OBSIDIAN) {\r\n                                isSafe = false;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (isSafe) {\r\n                        safeSpots.add(pos);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return safeSpots;\r\n    }\r\n\r\n    static {\r\n        surroundOffset = BlockUtil.toBlockPos(BlockUtil.getOffsets(0, true));\r\n    }\r\n    @Override\r\n    public void onRender3D(Render3DEvent event) {\r\n        assert (mc.renderViewEntity != null);\r\n        Vec3i playerPos = new Vec3i(mc.renderViewEntity.posX, mc.renderViewEntity.posY, mc.renderViewEntity.posZ);\r\n        for (int x = playerPos.getX() -  5; x < playerPos.getX() + this.range.getCurrentState(); ++x) {\r\n            for (int z = playerPos.getZ() - 5; z < playerPos.getZ() + this.range.getCurrentState(); ++z) {\r\n                for (int y = playerPos.getY() + 5; y > playerPos.getY() - 5; --y) {\r\n                    BlockPos pos = new BlockPos(x, y, z);\r\n                    if (!mc.world.getBlockState(pos).getBlock().equals(Blocks.AIR) || !mc.world.getBlockState(pos.add(0, 1, 0)).getBlock().equals(Blocks.AIR) || !mc.world.getBlockState(pos.add(0, 2, 0)).getBlock().equals(Blocks.AIR) || pos.equals(new BlockPos(mc.player.posX, mc.player.posY, mc.player.posZ)) && !isPosInFov(pos) && this.fov.getCurrentState())\r\n                        continue;\r\n                    if (mc.world.getBlockState(pos.north()).getBlock() == Blocks.BEDROCK && mc.world.getBlockState(pos.east()).getBlock() == Blocks.BEDROCK && mc.world.getBlockState(pos.west()).getBlock() == Blocks.BEDROCK && mc.world.getBlockState(pos.south()).getBlock() == Blocks.BEDROCK && mc.world.getBlockState(pos.down()).getBlock() == Blocks.BEDROCK) {\r\n                        RenderUtil.drawBoxESP(pos, new Color(this.red.getCurrentState(), this.green.getCurrentState(), this.blue.getCurrentState(), this.alpha.getCurrentState()), this.outline.getCurrentState(), new Color(this.cRed.getCurrentState(), this.cGreen.getCurrentState(), this.cBlue.getCurrentState(), this.cAlpha.getCurrentState()), this.lineWidth.getCurrentState().floatValue(), this.outline.getCurrentState(), this.box.getCurrentState(), this.boxAlpha.getCurrentState(), true);\r\n                        continue;\r\n                    }\r\n                    if (isBlockUnSafe(mc.world.getBlockState(pos.down()).getBlock()) || isBlockUnSafe(mc.world.getBlockState(pos.east()).getBlock()) || isBlockUnSafe(mc.world.getBlockState(pos.west()).getBlock()) || isBlockUnSafe(mc.world.getBlockState(pos.south()).getBlock()) || isBlockUnSafe(mc.world.getBlockState(pos.north()).getBlock()))\r\n                        continue;\r\n                    RenderUtil.drawBoxESP(pos, new Color(this.red.getCurrentState(), this.green.getCurrentState(), this.blue.getCurrentState(), this.alpha.getCurrentState()), this.outline.getCurrentState(), new Color(this.cRed.getCurrentState(), this.cGreen.getCurrentState(), this.cBlue.getCurrentState(), this.cAlpha.getCurrentState()), this.lineWidth.getCurrentState().floatValue(), this.outline.getCurrentState(), this.box.getCurrentState(), this.boxAlpha.getCurrentState(), true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private static final List<Block> unSafeBlocks = Arrays.asList(Blocks.OBSIDIAN, Blocks.BEDROCK, Blocks.ENDER_CHEST, Blocks.ANVIL);\r\n    private static boolean isBlockUnSafe(Block block) { return !unSafeBlocks.contains(block); }\r\n    private static Boolean isPosInFov(BlockPos pos) { int dirnumber = EntityUtil.getDirection4D();if (dirnumber == 0 && (double) pos.getZ() - BlockUtil.mc.player.getPositionVector().z < 0.0) { return false; }if (dirnumber == 1 && (double) pos.getX() - BlockUtil.mc.player.getPositionVector().x > 0.0) { return false; }if (dirnumber == 2 && (double) pos.getZ() - BlockUtil.mc.player.getPositionVector().z > 0.0) { return false; }return dirnumber != 3 || (double) pos.getX() - BlockUtil.mc.player.getPositionVector().x >= 0.0; }\r\n\r\n    public String hudInfoString(){\r\n        return \"Auto | \" + target.getName();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Client-2.0.0-github/Client-2.0.0/src/main/java/client/modules/combat/Holefiller.java	(revision 39d2239e4afec5f60e16cc39bd43c031a1396cff)
+++ Client-2.0.0-github/Client-2.0.0/src/main/java/client/modules/combat/Holefiller.java	(date 1630735907916)
@@ -178,6 +178,6 @@
     private static Boolean isPosInFov(BlockPos pos) { int dirnumber = EntityUtil.getDirection4D();if (dirnumber == 0 && (double) pos.getZ() - BlockUtil.mc.player.getPositionVector().z < 0.0) { return false; }if (dirnumber == 1 && (double) pos.getX() - BlockUtil.mc.player.getPositionVector().x > 0.0) { return false; }if (dirnumber == 2 && (double) pos.getZ() - BlockUtil.mc.player.getPositionVector().z > 0.0) { return false; }return dirnumber != 3 || (double) pos.getX() - BlockUtil.mc.player.getPositionVector().x >= 0.0; }
 
     public String hudInfoString(){
-        return "Auto | " + target.getName();
+        return "Auto";
     }
 }
Index: Client-2.0.0-github/Client-2.0.0/src/main/java/client/modules/movement/YPort.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package client.modules.movement;\r\n\r\nimport client.Client;\r\nimport client.modules.Module;\r\nimport client.gui.impl.setting.Setting;\r\nimport client.util.EntityUtil;\r\nimport client.util.Timer;\r\n\r\npublic class YPort extends Module {\r\n    private final Setting<Double> speed;\r\n    public Setting<String> futurePrefix;\r\n    private final Timer timer;\r\n\r\n    public YPort() {\r\n        super(\"Longjump\", \"Removing soon.\", Module.Category.MOVEMENT);\r\n        this.speed = register(new Setting(\"Speed\", 0.1, 0.0, 1.0D));\r\n        this.futurePrefix = register(new Setting(\"FuturePrefix\", \".\"));\r\n        this.timer = new Timer();\r\n    }\r\n    public void onDisable() {\r\n        this.timer.reset();\r\n        EntityUtil.resetTimer();\r\n    }\r\n\r\n    public void onUpdate() {\r\n        if (mc.player.isSneaking() || mc.player.isInWater() || mc.player.isInLava() || mc.player.isOnLadder() || Client.moduleManager.isModuleEnabled(\"Strafe\"))\r\n            return;\r\n        if (mc.player == null || mc.world == null) {\r\n            disable();\r\n            return;\r\n        }\r\n        handleYPortSpeed();\r\n\r\n        if(Step.mc.player.collidedHorizontally && Step.mc.player.onGround){\r\n            disable();\r\n            mc.player.sendChatMessage(futurePrefix.getCurrentState() + \"toggle Speed\");\r\n            Step.getInstance().enable();\r\n        }\r\n    }\r\n\r\n    public void onToggle() {\r\n        mc.player.motionY = -3.0D;\r\n        mc.player.stepHeight = 0.6f;\r\n    }\r\n\r\n    private void handleYPortSpeed() {\r\n        if (!EntityUtil.isMoving(mc.player) || (mc.player.isInWater() && mc.player.isInLava()) || mc.player.collidedHorizontally)\r\n            return;\r\n        if (mc.player.onGround) {\r\n            mc.player.jump();\r\n            EntityUtil.setSpeed(mc.player, EntityUtil.getBaseMoveSpeed() + this.speed.getCurrentState());\r\n        } else {\r\n            mc.player.motionY = -1.0D;\r\n        }\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Client-2.0.0-github/Client-2.0.0/src/main/java/client/modules/movement/YPort.java	(revision 39d2239e4afec5f60e16cc39bd43c031a1396cff)
+++ Client-2.0.0-github/Client-2.0.0/src/main/java/client/modules/movement/YPort.java	(date 1630734618640)
@@ -8,13 +8,11 @@
 
 public class YPort extends Module {
     private final Setting<Double> speed;
-    public Setting<String> futurePrefix;
     private final Timer timer;
 
     public YPort() {
-        super("Longjump", "Removing soon.", Module.Category.MOVEMENT);
+        super("YPort", "Removing soon.", Module.Category.MOVEMENT);
         this.speed = register(new Setting("Speed", 0.1, 0.0, 1.0D));
-        this.futurePrefix = register(new Setting("FuturePrefix", "."));
         this.timer = new Timer();
     }
     public void onDisable() {
@@ -30,12 +28,6 @@
             return;
         }
         handleYPortSpeed();
-
-        if(Step.mc.player.collidedHorizontally && Step.mc.player.onGround){
-            disable();
-            mc.player.sendChatMessage(futurePrefix.getCurrentState() + "toggle Speed");
-            Step.getInstance().enable();
-        }
     }
 
     public void onToggle() {
Index: Client-2.0.0-github/Client-2.0.0/src/main/java/client/util/BlockUtil.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package client.util;\r\n\r\nimport client.Client;\r\nimport client.command.Command;\r\nimport net.minecraft.block.*;\r\nimport net.minecraft.block.material.Material;\r\nimport net.minecraft.block.state.IBlockState;\r\nimport net.minecraft.entity.Entity;\r\nimport net.minecraft.entity.item.EntityEnderCrystal;\r\nimport net.minecraft.entity.item.EntityItem;\r\nimport net.minecraft.entity.item.EntityXPOrb;\r\nimport net.minecraft.entity.player.EntityPlayer;\r\nimport net.minecraft.init.Blocks;\r\nimport net.minecraft.network.play.client.*;\r\nimport net.minecraft.util.EnumFacing;\r\nimport net.minecraft.util.EnumHand;\r\nimport net.minecraft.util.NonNullList;\r\nimport net.minecraft.util.math.*;\r\n\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\n\r\npublic class BlockUtil implements Util {\r\n\r\n    public static void placeCrystalOnBlockHacker(final BlockPos pos, final EnumHand hand) {\r\n        final RayTraceResult result = BlockUtil.mc.world.rayTraceBlocks(new Vec3d(BlockUtil.mc.player.posX, BlockUtil.mc.player.posY + BlockUtil.mc.player.getEyeHeight(), BlockUtil.mc.player.posZ), new Vec3d(pos.getX() + 0.5, pos.getY() - 0.5, pos.getZ() + 0.5));\r\n        final EnumFacing facing = (result == null || result.sideHit == null) ? EnumFacing.UP : result.sideHit;\r\n        BlockUtil.mc.player.connection.sendPacket( new CPacketPlayerTryUseItemOnBlock(pos, facing, hand, 0.0f, 0.0f, 0.0f) );\r\n    }\r\n    public static List<BlockPos> possiblePlacePositions(final float placeRange) {\r\n        final NonNullList<BlockPos> positions = NonNullList.create();\r\n        positions.addAll( getSphere(EntityUtil.getPlayerPos( BlockUtil.mc.player ), placeRange, (int)placeRange, false, true, 0).stream().filter(BlockUtil::canPlaceCrystal).collect(Collectors.toList()) );\r\n        return positions;\r\n    }\r\n    public static List<BlockPos> possiblePlacePositions(final float placeRange, final boolean specialEntityCheck, final boolean oneDot15) {\r\n        final NonNullList<BlockPos> positions = NonNullList.create();\r\n        positions.addAll( getSphere(EntityUtil.getPlayerPos( BlockUtil.mc.player ), placeRange, (int)placeRange, false, true, 0).stream().filter( pos -> canPlaceCrystal(pos, specialEntityCheck, oneDot15)).collect(Collectors.toList()) );\r\n        return positions;\r\n    }\r\n\r\n    public static boolean canPlaceCrystal(final BlockPos blockPos) {\r\n        final BlockPos boost = blockPos.add(0, 1, 0);\r\n        final BlockPos boost2 = blockPos.add(0, 2, 0);\r\n        try {\r\n            return (BlockUtil.mc.world.getBlockState(blockPos).getBlock() == Blocks.BEDROCK || BlockUtil.mc.world.getBlockState(blockPos).getBlock() == Blocks.OBSIDIAN) && BlockUtil.mc.world.getBlockState(boost).getBlock() == Blocks.AIR && BlockUtil.mc.world.getBlockState(boost2).getBlock() == Blocks.AIR && BlockUtil.mc.world.getEntitiesWithinAABB( Entity.class , new AxisAlignedBB(boost)).isEmpty() && BlockUtil.mc.world.getEntitiesWithinAABB( Entity.class , new AxisAlignedBB(boost2)).isEmpty();\r\n        }\r\n        catch (Exception e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static boolean canPlaceCrystal(final BlockPos blockPos, final boolean specialEntityCheck, final boolean oneDot15) {\r\n        final BlockPos boost = blockPos.add(0, 1, 0);\r\n        final BlockPos boost2 = blockPos.add(0, 2, 0);\r\n        try {\r\n            if (BlockUtil.mc.world.getBlockState(blockPos).getBlock() != Blocks.BEDROCK && BlockUtil.mc.world.getBlockState(blockPos).getBlock() != Blocks.OBSIDIAN) {\r\n                return false;\r\n            }\r\n            if ((BlockUtil.mc.world.getBlockState(boost).getBlock() != Blocks.AIR || BlockUtil.mc.world.getBlockState(boost2).getBlock() != Blocks.AIR) && !oneDot15) {\r\n                return false;\r\n            }\r\n            if (!specialEntityCheck) {\r\n                return BlockUtil.mc.world.getEntitiesWithinAABB( Entity.class , new AxisAlignedBB(boost)).isEmpty() && (oneDot15 || BlockUtil.mc.world.getEntitiesWithinAABB( Entity.class , new AxisAlignedBB(boost2)).isEmpty());\r\n            }\r\n            for (final Entity entity : BlockUtil.mc.world.getEntitiesWithinAABB(Entity.class, new AxisAlignedBB(boost))) {\r\n                if (!(entity instanceof EntityEnderCrystal)) {\r\n                    return false;\r\n                }\r\n            }\r\n            if (!oneDot15) {\r\n                for (final Entity entity : BlockUtil.mc.world.getEntitiesWithinAABB(Entity.class, new AxisAlignedBB(boost2))) {\r\n                    if (!(entity instanceof EntityEnderCrystal)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        catch (Exception ignored) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static final List<Block> unSafeBlocks = Arrays.asList(Blocks.OBSIDIAN, Blocks.BEDROCK, Blocks.ENDER_CHEST, Blocks.ANVIL);\r\n    public static boolean isBlockUnSolid(BlockPos pos) {\r\n        return BlockUtil.isBlockUnSolid(BlockUtil.mc.world.getBlockState(pos).getBlock());\r\n    }\r\n\r\n    public static boolean isBlockUnSolid(Block block) {\r\n        return unSolidBlocks.contains(block);\r\n    }\r\n\r\n    public static List<BlockPos> getNearbyBlocks(EntityPlayer player, double blockRange, boolean motion) {\r\n        List<BlockPos> nearbyBlocks = new ArrayList<>();\r\n        int range = (int) MathUtil.roundDouble(blockRange, 0);\r\n\r\n        if (motion)\r\n            player.getPosition().add(new Vec3i(player.motionX, player.motionY, player.motionZ));\r\n\r\n        for (int x = -range; x <= range; x++)\r\n            for (int y = -range; y <= range - (range / 2); y++)\r\n                for (int z = -range; z <= range; z++)\r\n                    nearbyBlocks.add(player.getPosition().add(x, y, z));\r\n\r\n        return nearbyBlocks;\r\n    }\r\n\r\n    public static Vec3d[] holeOffsets;\r\n    static {\r\n        BlockUtil.holeOffsets = new Vec3d[] { new Vec3d(-1.0, 0.0, 0.0), new Vec3d(1.0, 0.0, 0.0), new Vec3d(0.0, 0.0, -1.0), new Vec3d(0.0, 0.0, 1.0), new Vec3d(0.0, -1.0, 0.0) };\r\n    }\r\n    public static final List<Block> blackList = Arrays.asList(Blocks.ENDER_CHEST, Blocks.CHEST, Blocks.TRAPPED_CHEST, Blocks.CRAFTING_TABLE, Blocks.ANVIL, Blocks.BREWING_STAND, Blocks.HOPPER, Blocks.DROPPER, Blocks.DISPENSER, Blocks.TRAPDOOR, Blocks.ENCHANTING_TABLE);\r\n    public static final List<Block> shulkerList = Arrays.asList(Blocks.WHITE_SHULKER_BOX, Blocks.ORANGE_SHULKER_BOX, Blocks.MAGENTA_SHULKER_BOX, Blocks.LIGHT_BLUE_SHULKER_BOX, Blocks.YELLOW_SHULKER_BOX, Blocks.LIME_SHULKER_BOX, Blocks.PINK_SHULKER_BOX, Blocks.GRAY_SHULKER_BOX, Blocks.SILVER_SHULKER_BOX, Blocks.CYAN_SHULKER_BOX, Blocks.PURPLE_SHULKER_BOX, Blocks.BLUE_SHULKER_BOX, Blocks.BROWN_SHULKER_BOX, Blocks.GREEN_SHULKER_BOX, Blocks.RED_SHULKER_BOX, Blocks.BLACK_SHULKER_BOX);\r\n    public static List<Block> unSolidBlocks = Arrays.asList(Blocks.FLOWING_LAVA, Blocks.FLOWER_POT, Blocks.SNOW, Blocks.CARPET, Blocks.END_ROD, Blocks.SKULL, Blocks.FLOWER_POT, Blocks.TRIPWIRE, Blocks.TRIPWIRE_HOOK, Blocks.WOODEN_BUTTON, Blocks.LEVER, Blocks.STONE_BUTTON, Blocks.LADDER, Blocks.UNPOWERED_COMPARATOR, Blocks.POWERED_COMPARATOR, Blocks.UNPOWERED_REPEATER, Blocks.POWERED_REPEATER, Blocks.UNLIT_REDSTONE_TORCH, Blocks.REDSTONE_TORCH, Blocks.REDSTONE_WIRE, Blocks.AIR, Blocks.PORTAL, Blocks.END_PORTAL, Blocks.WATER, Blocks.FLOWING_WATER, Blocks.LAVA, Blocks.FLOWING_LAVA, Blocks.SAPLING, Blocks.RED_FLOWER, Blocks.YELLOW_FLOWER, Blocks.BROWN_MUSHROOM, Blocks.RED_MUSHROOM, Blocks.WHEAT, Blocks.CARROTS, Blocks.POTATOES, Blocks.BEETROOTS, Blocks.REEDS, Blocks.PUMPKIN_STEM, Blocks.MELON_STEM, Blocks.WATERLILY, Blocks.NETHER_WART, Blocks.COCOA, Blocks.CHORUS_FLOWER, Blocks.CHORUS_PLANT, Blocks.TALLGRASS, Blocks.DEADBUSH, Blocks.VINE, Blocks.FIRE, Blocks.RAIL, Blocks.ACTIVATOR_RAIL, Blocks.DETECTOR_RAIL, Blocks.GOLDEN_RAIL, Blocks.TORCH);\r\n\r\n    public static boolean canBreak(BlockPos pos) {\r\n        IBlockState blockState = BlockUtil.mc.world.getBlockState(pos);\r\n        Block block = blockState.getBlock();\r\n        return block.getBlockHardness(blockState, BlockUtil.mc.world, pos) != -1.0f;\r\n    }\r\n\r\n    public static EntityPlayer getTarget(final float range) {\r\n        EntityPlayer currentTarget = null;\r\n        for (final EntityPlayer player : mc.world.playerEntities) {\r\n            if (EntityUtil.isntValid(player, range)) {\r\n                continue;\r\n            }\r\n            if (currentTarget == null) {\r\n                currentTarget = player;\r\n            }\r\n            else {\r\n                if (mc.player.getDistanceSq(player) >= mc.player.getDistanceSq(currentTarget)) {\r\n                    continue;\r\n                }\r\n                currentTarget = player;\r\n            }\r\n        }\r\n        return currentTarget;\r\n    }\r\n\r\n    public static boolean isInHole(final EntityPlayer entity) {\r\n        return isBlockValid(new BlockPos(entity.posX, entity.posY, entity.posZ));\r\n    }\r\n\r\n    public static boolean isBlockValid(final BlockPos blockPos) {\r\n        return isBedrockHole(blockPos) || isObbyHole(blockPos) || isBothHole(blockPos);\r\n    }\r\n\r\n    public static boolean isObbyHole(final BlockPos blockPos) {\r\n        final BlockPos[] array;\r\n        final BlockPos[] touchingBlocks = array = new BlockPos[] { blockPos.north(), blockPos.south(), blockPos.east(), blockPos.west(), blockPos.down() };\r\n        for (final BlockPos pos : array) {\r\n            final IBlockState touchingState = mc.world.getBlockState(pos);\r\n            if (touchingState.getBlock() != Blocks.OBSIDIAN) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static boolean isBedrockHole(final BlockPos blockPos) {\r\n        final BlockPos[] array;\r\n        final BlockPos[] touchingBlocks = array = new BlockPos[] { blockPos.north(), blockPos.south(), blockPos.east(), blockPos.west(), blockPos.down() };\r\n        for (final BlockPos pos : array) {\r\n            final IBlockState touchingState = mc.world.getBlockState(pos);\r\n            if (touchingState.getBlock() != Blocks.BEDROCK) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static boolean isBothHole(final BlockPos blockPos) {\r\n        final BlockPos[] array;\r\n        final BlockPos[] touchingBlocks = array = new BlockPos[] { blockPos.north(), blockPos.south(), blockPos.east(), blockPos.west(), blockPos.down() };\r\n        for (final BlockPos pos : array) {\r\n            final IBlockState touchingState = mc.world.getBlockState(pos);\r\n            if (touchingState.getBlock() != Blocks.BEDROCK && touchingState.getBlock() != Blocks.OBSIDIAN) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static List<BlockPos> getSphere(final double radius, final boolean ignoreAir) {\r\n        final ArrayList<BlockPos> sphere = new ArrayList<>();\r\n        final BlockPos pos = new BlockPos(BlockUtil.mc.player.getPositionVector());\r\n        final int posX = pos.getX();\r\n        final int posY = pos.getY();\r\n        final int posZ = pos.getZ();\r\n        final int radiuss = (int)radius;\r\n        for (int x = posX - radiuss; x <= posX + radius; ++x) {\r\n            for (int z = posZ - radiuss; z <= posZ + radius; ++z) {\r\n                for (int y = posY - radiuss; y < posY + radius; ++y) {\r\n                    final double dist = (posX - x) * (posX - x) + (posZ - z) * (posZ - z) + (posY - y) * (posY - y);\r\n                    final BlockPos position;\r\n                    if (dist < radius * radius && (BlockUtil.mc.world.getBlockState(position = new BlockPos(x, y, z)).getBlock() != Blocks.AIR || !ignoreAir)) {\r\n                        sphere.add(position);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sphere;\r\n    }\r\n    public static boolean placeBlockSmartRotate(BlockPos pos, EnumHand hand, boolean rotate, boolean packet, boolean isSneaking) {\r\n        boolean sneaking = false;\r\n        EnumFacing side = BlockUtil.getFirstFacing(pos);\r\n        Command.sendMessage( Objects.requireNonNull ( side ).toString());\r\n        if (side == null) {\r\n            return isSneaking;\r\n        }\r\n        BlockPos neighbour = pos.offset(side);\r\n        EnumFacing opposite = side.getOpposite();\r\n        Vec3d hitVec = new Vec3d(neighbour).add(0.5, 0.5, 0.5).add(new Vec3d(opposite.getDirectionVec()).scale(0.5));\r\n        Block neighbourBlock = BlockUtil.mc.world.getBlockState(neighbour).getBlock();\r\n        if (!BlockUtil.mc.player.isSneaking() && (blackList.contains(neighbourBlock) || shulkerList.contains(neighbourBlock))) {\r\n            BlockUtil.mc.player.connection.sendPacket(new CPacketEntityAction(BlockUtil.mc.player, CPacketEntityAction.Action.START_SNEAKING));\r\n            sneaking = true;\r\n        }\r\n        if (rotate) {\r\n            Client.rotationManager.lookAtVec3d(hitVec);\r\n        }\r\n        BlockUtil.rightClickBlock(neighbour, hitVec, hand, opposite, packet);\r\n        BlockUtil.mc.player.swingArm(EnumHand.MAIN_HAND);\r\n        BlockUtil.mc.rightClickDelayTimer = 4;\r\n        return sneaking || isSneaking;\r\n    }\r\n\r\n    public static void placeCrystalOnBlock(BlockPos pos, EnumHand hand, boolean swing) {\r\n        RayTraceResult result = mc.world.rayTraceBlocks(new Vec3d(mc.player.posX, mc.player.posY + (double) mc.player.getEyeHeight(), mc.player.posZ), new Vec3d((double) pos.getX() + 0.5, (double) pos.getY() - 0.5, (double) pos.getZ() + 0.5));\r\n        EnumFacing facing = result == null || result.sideHit == null ? EnumFacing.UP : result.sideHit;\r\n        mc.player.connection.sendPacket(new CPacketPlayerTryUseItemOnBlock(pos, facing, hand, 0.0f, 0.0f, 0.0f));\r\n        if (swing) {\r\n            mc.player.connection.sendPacket(new CPacketAnimation(hand));\r\n        }\r\n    }\r\n\r\n    public static void faceVectorPacketInstant(final Vec3d vec) {\r\n        final float[] rotations = getNeededRotations2(vec);\r\n        BlockUtil.mc.player.connection.sendPacket( new CPacketPlayer.Rotation(rotations[0], rotations[1], BlockUtil.mc.player.onGround) );\r\n    }\r\n\r\n    private static float[] getNeededRotations2(final Vec3d vec) {\r\n        final Vec3d eyesPos = getEyesPos();\r\n        final double diffX = vec.x - eyesPos.x;\r\n        final double diffY = vec.y - eyesPos.y;\r\n        final double diffZ = vec.z - eyesPos.z;\r\n        final double diffXZ = Math.sqrt(diffX * diffX + diffZ * diffZ);\r\n        final float yaw = (float)Math.toDegrees(Math.atan2(diffZ, diffX)) - 90.0f;\r\n        final float pitch = (float)(-Math.toDegrees(Math.atan2(diffY, diffXZ)));\r\n        return new float[] { BlockUtil.mc.player.rotationYaw + MathHelper.wrapDegrees(yaw - BlockUtil.mc.player.rotationYaw), BlockUtil.mc.player.rotationPitch + MathHelper.wrapDegrees(pitch - BlockUtil.mc.player.rotationPitch) };\r\n    }\r\n\r\n    public static Vec3d getEyesPos() {\r\n        return new Vec3d(BlockUtil.mc.player.posX, BlockUtil.mc.player.posY + BlockUtil.mc.player.getEyeHeight(), BlockUtil.mc.player.posZ);\r\n    }\r\n\r\n    public static List<BlockPos> getCircle(final BlockPos loc, final int y, final float r, final boolean hollow) {\r\n        final List<BlockPos> circleblocks = new ArrayList <> ( );\r\n        final int cx = loc.getX();\r\n        final int cz = loc.getZ();\r\n        for (int x = cx - (int)r; x <= cx + r; ++x) {\r\n            for (int z = cz - (int)r; z <= cz + r; ++z) {\r\n                final double dist = (cx - x) * (cx - x) + (cz - z) * (cz - z);\r\n                if (dist < r * r && (!hollow || dist >= (r - 1.0f) * (r - 1.0f))) {\r\n                    final BlockPos l = new BlockPos(x, y, z);\r\n                    circleblocks.add(l);\r\n                }\r\n            }\r\n        }\r\n        return circleblocks;\r\n    }\r\n\r\n    public static EnumFacing getPlaceableSide(final BlockPos pos) {\r\n        for (final EnumFacing side : EnumFacing.values()) {\r\n            final BlockPos neighbour = pos.offset(side);\r\n            if (BlockUtil.mc.world.getBlockState(neighbour).getBlock().canCollideCheck(BlockUtil.mc.world.getBlockState(neighbour), false)) {\r\n                final IBlockState blockState = BlockUtil.mc.world.getBlockState(neighbour);\r\n                if (!blockState.getMaterial().isReplaceable()) {\r\n                    return side;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    public static BlockSafety isBlockSafe(Block block) {\r\n        if (block == Blocks.BEDROCK) {\r\n            return BlockSafety.UNBREAKABLE;\r\n        }\r\n        if (block == Blocks.OBSIDIAN || block == Blocks.ENDER_CHEST || block == Blocks.ANVIL) {\r\n            return BlockSafety.RESISTANT;\r\n        }\r\n        return BlockSafety.BREAKABLE;\r\n    }\r\n    public static List<BlockPos> getSphereSecondary(float radius, boolean ignoreAir) {\r\n        final List<BlockPos> sphere = new ArrayList<>();\r\n\r\n        final BlockPos pos = new BlockPos(mc.player.getPositionVector());\r\n\r\n        final int posX = pos.getX();\r\n        final int posY = pos.getY();\r\n        final int posZ = pos.getZ();\r\n\r\n        final int radiuss = (int) radius;\r\n\r\n        for (int x = posX - radiuss; x <= posX + radius; x++) {\r\n            for (int z = posZ - radiuss; z <= posZ + radius; z++) {\r\n                for (int y = posY - radiuss; y < posY + radius; y++) {\r\n                    if ((posX - x) * (posX - x) + (posZ - z) * (posZ - z) + (posY - y) * (posY - y) < radius * radius) {\r\n                        final BlockPos position = new BlockPos(x, y, z);\r\n                        if (ignoreAir && mc.world.getBlockState(position).getBlock() == Blocks.AIR) {\r\n                            continue;\r\n                        }\r\n                        sphere.add(position);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return sphere;\r\n    }\r\n\r\n    public static final Vec3d[] antiDropOffsetList = {\r\n            new Vec3d(0, -2, 0),\r\n    };\r\n\r\n    public static final Vec3d[] platformOffsetList = {\r\n            new Vec3d(0, -1, 0),\r\n            new Vec3d(0, -1, -1),\r\n            new Vec3d(0, -1, 1),\r\n            new Vec3d(-1, -1, 0),\r\n            new Vec3d(1, -1, 0)\r\n    };\r\n\r\n    public static final Vec3d[] legOffsetList = {\r\n            new Vec3d(-1, 0, 0),\r\n            new Vec3d(1, 0, 0),\r\n            new Vec3d(0, 0, -1),\r\n            new Vec3d(0, 0, 1)\r\n    };\r\n\r\n    public static final Vec3d[] offsetList = {\r\n            new Vec3d(1, 1, 0),\r\n            new Vec3d(-1, 1, 0),\r\n            new Vec3d(0, 1, 1),\r\n            new Vec3d(0, 1, -1),\r\n            new Vec3d(0, 2, 0),\r\n            //new Vec3d(0, 2, -1)\r\n    };\r\n\r\n    public static final Vec3d[] antiStepOffsetList = {\r\n            new Vec3d(-1, 2, 0),\r\n            new Vec3d(1, 2, 0),\r\n            new Vec3d(0, 2, 1),\r\n            new Vec3d(0, 2, -1),\r\n    };\r\n\r\n    public static final Vec3d[] antiScaffoldOffsetList = {\r\n            new Vec3d(0, 3, 0)\r\n    };\r\n\r\n    public static boolean canPlaceCrystal(final BlockPos blockPos, boolean check) {\r\n        final BlockPos boost = blockPos.add(0, 1, 0);\r\n        if (mc.world.getBlockState(blockPos).getBlock() != Blocks.BEDROCK && mc.world.getBlockState(blockPos).getBlock() != Blocks.OBSIDIAN) {\r\n            return false;\r\n        }\r\n\r\n        final BlockPos boost2 = blockPos.add(0, 2, 0);\r\n        if (mc.world.getBlockState(boost).getBlock() != Blocks.AIR || mc.world.getBlockState(boost2).getBlock() != Blocks.AIR) {\r\n            return false;\r\n        }\r\n\r\n        for (Entity entity : mc.world.getEntitiesWithinAABB(Entity.class, new AxisAlignedBB(boost))) {\r\n            if (entity.isDead || entity instanceof EntityEnderCrystal)\r\n                continue;\r\n\r\n            return false;\r\n        }\r\n\r\n        if (check) {\r\n            for (final Entity entity : mc.world.getEntitiesWithinAABB(Entity.class, new AxisAlignedBB(boost2))) {\r\n                if (entity.isDead || entity instanceof EntityEnderCrystal)\r\n                    continue;\r\n\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    public static HoleInfo isHole(BlockPos centreBlock, boolean onlyOneWide, boolean ignoreDown) {\r\n        HoleInfo output = new HoleInfo();\r\n        HashMap<BlockOffset, BlockSafety> unsafeSides = BlockUtil.getUnsafeSides(centreBlock);\r\n\r\n        if (unsafeSides.containsKey(BlockUtil.BlockOffset.DOWN)) {\r\n            if (unsafeSides.remove(BlockUtil.BlockOffset.DOWN, BlockUtil.BlockSafety.BREAKABLE)) {\r\n                if (!ignoreDown) {\r\n                    output.setSafety(BlockSafety.BREAKABLE);\r\n                    return output;\r\n                }\r\n            }\r\n        }\r\n\r\n        int size = unsafeSides.size();\r\n\r\n        unsafeSides.entrySet().removeIf(entry -> entry.getValue() == BlockUtil.BlockSafety.RESISTANT);\r\n\r\n        // size has changed so must have weak side\r\n        if (unsafeSides.size() != size) {\r\n            output.setSafety(BlockSafety.RESISTANT);\r\n        }\r\n\r\n        size = unsafeSides.size();\r\n\r\n        // is it a perfect hole\r\n        if (size == 0) {\r\n            output.setType(HoleType.SINGLE);\r\n            output.setCentre(new AxisAlignedBB(centreBlock));\r\n            return output;\r\n        }\r\n        // have one open side\r\n        else if (size == 1 && !onlyOneWide) {\r\n            return isDoubleHole(output, centreBlock, unsafeSides.keySet().stream().findFirst().get());\r\n        } else {\r\n            output.setSafety(BlockSafety.BREAKABLE);\r\n            return output;\r\n        }\r\n    }\r\n\r\n    private static HoleInfo isDoubleHole(HoleInfo info, BlockPos centreBlock, BlockOffset weakSide) {\r\n        BlockPos unsafePos = weakSide.offset(centreBlock);\r\n\r\n        HashMap<BlockUtil.BlockOffset, BlockUtil.BlockSafety> unsafeSides = BlockUtil.getUnsafeSides(unsafePos);\r\n\r\n        int size = unsafeSides.size();\r\n\r\n        unsafeSides.entrySet().removeIf(entry -> entry.getValue() == BlockUtil.BlockSafety.RESISTANT);\r\n\r\n        // size has changed so must have weak side\r\n        if (unsafeSides.size() != size) {\r\n            info.setSafety(BlockSafety.RESISTANT);\r\n        }\r\n\r\n        if (unsafeSides.containsKey(BlockUtil.BlockOffset.DOWN)) {\r\n            info.setType(HoleType.CUSTOM);\r\n            unsafeSides.remove(BlockUtil.BlockOffset.DOWN);\r\n        }\r\n\r\n        // is it a safe hole\r\n        if (unsafeSides.size() > 1) {\r\n            info.setType(HoleType.NONE);\r\n            return info;\r\n        }\r\n\r\n        // it is\r\n        double minX = Math.min(centreBlock.getX(), unsafePos.getX());\r\n        double maxX = Math.max(centreBlock.getX(), unsafePos.getX()) + 1;\r\n        double minZ = Math.min(centreBlock.getZ(), unsafePos.getZ());\r\n        double maxZ = Math.max(centreBlock.getZ(), unsafePos.getZ()) + 1;\r\n\r\n        info.setCentre(new AxisAlignedBB(minX, centreBlock.getY(), minZ, maxX, centreBlock.getY() + 1, maxZ));\r\n\r\n        if (info.getType() != HoleType.CUSTOM) {\r\n            info.setType(HoleType.DOUBLE);\r\n        }\r\n        return info;\r\n    }\r\n\r\n    public static HashMap<BlockOffset, BlockSafety> getUnsafeSides(BlockPos pos) {\r\n        HashMap<BlockOffset, BlockSafety> output = new HashMap<>();\r\n        BlockSafety temp;\r\n\r\n        temp = isBlockSafe(mc.world.getBlockState(BlockOffset.DOWN.offset(pos)).getBlock());\r\n        if (temp != BlockSafety.UNBREAKABLE)\r\n            output.put(BlockOffset.DOWN, temp);\r\n\r\n        temp = isBlockSafe(mc.world.getBlockState(BlockOffset.NORTH.offset(pos)).getBlock());\r\n        if (temp != BlockSafety.UNBREAKABLE)\r\n            output.put(BlockOffset.NORTH, temp);\r\n\r\n        temp = isBlockSafe(mc.world.getBlockState(BlockOffset.SOUTH.offset(pos)).getBlock());\r\n        if (temp != BlockSafety.UNBREAKABLE)\r\n            output.put(BlockOffset.SOUTH, temp);\r\n\r\n        temp = isBlockSafe(mc.world.getBlockState(BlockOffset.EAST.offset(pos)).getBlock());\r\n        if (temp != BlockSafety.UNBREAKABLE)\r\n            output.put(BlockOffset.EAST, temp);\r\n\r\n        temp = isBlockSafe(mc.world.getBlockState(BlockOffset.WEST.offset(pos)).getBlock());\r\n        if (temp != BlockSafety.UNBREAKABLE)\r\n            output.put(BlockOffset.WEST, temp);\r\n\r\n        return output;\r\n    }\r\n\r\n    public enum BlockSafety {\r\n        UNBREAKABLE,\r\n        RESISTANT,\r\n        BREAKABLE\r\n    }\r\n\r\n    public enum HoleType {\r\n        SINGLE,\r\n        DOUBLE,\r\n        CUSTOM,\r\n        NONE\r\n    }\r\n\r\n    public static class HoleInfo {\r\n        private HoleType type;\r\n        private BlockSafety safety;\r\n\r\n        private AxisAlignedBB centre;\r\n\r\n        public HoleInfo() {\r\n            this(BlockSafety.UNBREAKABLE, HoleType.NONE);\r\n        }\r\n\r\n        public HoleInfo(BlockSafety safety, HoleType type) {\r\n            this.type = type;\r\n            this.safety = safety;\r\n        }\r\n\r\n        public void setType(HoleType type) {\r\n            this.type = type;\r\n        }\r\n\r\n        public void setSafety(BlockSafety safety) {\r\n            this.safety = safety;\r\n        }\r\n\r\n        public void setCentre(AxisAlignedBB centre) {\r\n            this.centre = centre;\r\n        }\r\n\r\n        public HoleType getType() {\r\n            return type;\r\n        }\r\n\r\n        public BlockSafety getSafety() {\r\n            return safety;\r\n        }\r\n\r\n        public AxisAlignedBB getCentre() {\r\n            return centre;\r\n        }\r\n    }\r\n\r\n    public enum BlockOffset {\r\n        DOWN(0, -1, 0),\r\n        UP(0, 1, 0),\r\n        NORTH(0, 0, -1),\r\n        EAST(1, 0, 0),\r\n        SOUTH(0, 0, 1),\r\n        WEST(-1, 0, 0);\r\n\r\n        private final int x;\r\n        private final int y;\r\n        private final int z;\r\n\r\n        BlockOffset(int x, int y, int z) {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.z = z;\r\n        }\r\n\r\n        public BlockPos offset(BlockPos pos) {\r\n            return pos.add(x, y, z);\r\n        }\r\n\r\n        public BlockPos forward(BlockPos pos, int scale) {\r\n            return pos.add(x * scale, 0, z * scale);\r\n        }\r\n\r\n        public BlockPos backward(BlockPos pos, int scale) {\r\n            return pos.add(-x * scale, 0, -z * scale);\r\n        }\r\n\r\n        // Don't ask me why they work but they do\r\n\r\n        public BlockPos left(BlockPos pos, int scale) {\r\n            return pos.add(z * scale, 0, -x * scale);\r\n        }\r\n\r\n        public BlockPos right(BlockPos pos, int scale) {\r\n            return pos.add(-z * scale, 0, x * scale);\r\n        }\r\n    }\r\n\r\n    public enum ValidResult {\r\n        NoEntityCollision,\r\n        AlreadyBlockThere,\r\n        NoNeighbors,\r\n        Ok,\r\n    }\r\n    public static BlockPos getRoundedBlockPos(Entity entity) {\r\n        return new BlockPos(MathUtil.roundVec(entity.getPositionVector(), 0));\r\n    }\r\n    public static boolean isSafe(final Entity entity, final int height, final boolean floor) {\r\n        return getUnsafeBlocks(entity, height, floor).size() == 0;\r\n    }\r\n    public static List<Vec3d> getUnsafeBlocks(final Entity entity, final int height, final boolean floor) {\r\n        return getUnsafeBlocksFromVec3d(entity.getPositionVector(), height, floor);\r\n    }\r\n    public static List<Vec3d> getUnsafeBlocksFromVec3d(final Vec3d pos, final int height, final boolean floor) {\r\n        final ArrayList<Vec3d> vec3ds = new ArrayList <> ( );\r\n        for (final Vec3d vector : getOffsets(height, floor)) {\r\n            final BlockPos targetPos = new BlockPos(pos).add(vector.x, vector.y, vector.z);\r\n            final Block block = Util.mc.world.getBlockState(targetPos).getBlock();\r\n            if (block instanceof BlockAir || block instanceof BlockLiquid || block instanceof BlockTallGrass || block instanceof BlockFire || block instanceof BlockDeadBush || block instanceof BlockSnow) {\r\n                vec3ds.add(vector);\r\n            }\r\n        }\r\n        return vec3ds;\r\n    }\r\n    public static Vec3d[] getUnsafeBlockArray(final Vec3d vec3d, final int height, final boolean floor) {\r\n        final List<Vec3d> list = getUnsafeBlocksFromVec3d(vec3d, height, floor);\r\n        final Vec3d[] array = new Vec3d[list.size()];\r\n        return list.toArray(array);\r\n    }\r\n\r\n    private static boolean hasNeighbour(final BlockPos blockPos) {\r\n        for (final EnumFacing side : EnumFacing.values()) {\r\n            final BlockPos neighbour = blockPos.offset(side);\r\n            if (!mc.world.getBlockState(neighbour).getMaterial().isReplaceable()) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public static boolean checkForNeighbours(final BlockPos blockPos) {\r\n        if (!hasNeighbour(blockPos)) {\r\n            for (final EnumFacing side : EnumFacing.values()) {\r\n                final BlockPos neighbour = blockPos.offset(side);\r\n                if (hasNeighbour(neighbour)) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public static EnumFacing getFirstFacing(BlockPos pos) {\r\n        Iterator<EnumFacing> iterator = BlockUtil.getPossibleSides(pos).iterator();\r\n        if (iterator.hasNext()) {\r\n            EnumFacing facing = iterator.next();\r\n            return facing;\r\n        }\r\n        return null;\r\n    }\r\n    public static void rightClickBlock(BlockPos pos, Vec3d vec, EnumHand hand, EnumFacing direction, boolean packet) {\r\n        if (packet) {\r\n            float f = (float) (vec.x - (double) pos.getX());\r\n            float f1 = (float) (vec.y - (double) pos.getY());\r\n            float f2 = (float) (vec.z - (double) pos.getZ());\r\n            BlockUtil.mc.player.connection.sendPacket(new CPacketPlayerTryUseItemOnBlock(pos, direction, hand, f, f1, f2));\r\n        } else {\r\n            BlockUtil.mc.playerController.processRightClickBlock(BlockUtil.mc.player, BlockUtil.mc.world, pos, direction, vec, hand);\r\n        }\r\n        BlockUtil.mc.player.swingArm(EnumHand.MAIN_HAND);\r\n        BlockUtil.mc.rightClickDelayTimer = 4;\r\n    }\r\n\r\n\r\n    public static boolean placeBlock(BlockPos pos, EnumHand hand, boolean rotate, boolean packet, boolean isSneaking) {\r\n        boolean sneaking = false;\r\n        EnumFacing side = BlockUtil.getFirstFacing(pos);\r\n        if (side == null) {\r\n            return isSneaking;\r\n        }\r\n        BlockPos neighbour = pos.offset(side);\r\n        EnumFacing opposite = side.getOpposite();\r\n        Vec3d hitVec = new Vec3d(neighbour).add(0.5, 0.5, 0.5).add(new Vec3d(opposite.getDirectionVec()).scale(0.5));\r\n        Block neighbourBlock = BlockUtil.mc.world.getBlockState(neighbour).getBlock();\r\n        if (!BlockUtil.mc.player.isSneaking() && (blackList.contains(neighbourBlock) || shulkerList.contains(neighbourBlock))) {\r\n            BlockUtil.mc.player.connection.sendPacket(new CPacketEntityAction(BlockUtil.mc.player, CPacketEntityAction.Action.START_SNEAKING));\r\n            BlockUtil.mc.player.setSneaking(true);\r\n            sneaking = true;\r\n        }\r\n        if (rotate) {\r\n            PlayerUtil.faceVector(hitVec, true);\r\n        }\r\n        BlockUtil.rightClickBlock(neighbour, hitVec, hand, opposite, packet);\r\n        BlockUtil.mc.player.swingArm(EnumHand.MAIN_HAND);\r\n        BlockUtil.mc.rightClickDelayTimer = 4;\r\n        return sneaking || isSneaking;\r\n    }\r\n\r\n\r\n    public static List<Vec3d> getOffsetList(final int y, final boolean floor) {\r\n        final ArrayList<Vec3d> offsets = new ArrayList <> ( );\r\n        offsets.add(new Vec3d(-1.0, y , 0.0));\r\n        offsets.add(new Vec3d(1.0, y , 0.0));\r\n        offsets.add(new Vec3d(0.0, y , -1.0));\r\n        offsets.add(new Vec3d(0.0, y , 1.0));\r\n        if (floor) {\r\n            offsets.add(new Vec3d(0.0, y - 1 , 0.0));\r\n        }\r\n        return offsets;\r\n    }\r\n\r\n    public static Vec3d[] getOffsets(final int y, final boolean floor) {\r\n        final List<Vec3d> offsets = getOffsetList(y, floor);\r\n        final Vec3d[] array = new Vec3d[offsets.size()];\r\n        return offsets.toArray(array);\r\n    }\r\n    public static List<BlockPos> getCock(final float radius, final boolean ignoreAir) {\r\n        final ArrayList<BlockPos> sphere = new ArrayList <> ( );\r\n        final BlockPos pos = new BlockPos(mc.player.getPositionVector());\r\n        final int posX = pos.getX();\r\n        final int posY = pos.getY();\r\n        final int posZ = pos.getZ();\r\n        final int radiuss = (int)radius;\r\n        for (int x = posX - radiuss; x <= posX + radius; ++x) {\r\n            for (int z = posZ - radiuss; z <= posZ + radius; ++z) {\r\n                for (int y = posY - radiuss; y < posY + radius; ++y) {\r\n                    final double dist = (posX - x) * (posX - x) + (posZ - z) * (posZ - z) + (posY - y) * (posY - y);\r\n                    final BlockPos position;\r\n                    if (dist < radius * radius && (mc.world.getBlockState(position = new BlockPos(x, y, z)).getBlock() != Blocks.AIR || !ignoreAir)) {\r\n                        sphere.add(position);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return sphere;\r\n    }\r\n\r\n\r\n    public static List<EnumFacing> getPossibleSides(BlockPos pos) {\r\n        ArrayList<EnumFacing> facings = new ArrayList<>();\r\n        for (EnumFacing side : EnumFacing.values()) {\r\n            IBlockState blockState;\r\n            BlockPos neighbour = pos.offset(side);\r\n            if (!mc.world.getBlockState(neighbour).getBlock().canCollideCheck(mc.world.getBlockState(neighbour), false) || (blockState = mc.world.getBlockState(neighbour)).getMaterial().isReplaceable())\r\n                continue;\r\n            facings.add(side);\r\n        }\r\n        return facings;\r\n    }\r\n\r\n    public static int isPositionPlaceable(BlockPos pos, boolean rayTrace) {\r\n        return BlockUtil.isPositionPlaceable(pos, rayTrace, true);\r\n    }\r\n\r\n    public static int isPositionPlaceable(BlockPos pos, boolean rayTrace, boolean entityCheck) {\r\n        Block block = mc.world.getBlockState(pos).getBlock();\r\n        if (!(block instanceof BlockAir || block instanceof BlockLiquid || block instanceof BlockTallGrass || block instanceof BlockFire || block instanceof BlockDeadBush || block instanceof BlockSnow)) {\r\n            return 0;\r\n        }\r\n        if (!BlockUtil.rayTracePlaceCheck(pos, rayTrace, 0.0f)) {\r\n            return -1;\r\n        }\r\n        if (entityCheck) {\r\n            for (Entity entity : mc.world.getEntitiesWithinAABB(Entity.class, new AxisAlignedBB(pos))) {\r\n                if (entity instanceof EntityItem || entity instanceof EntityXPOrb) continue;\r\n                return 1;\r\n            }\r\n        }\r\n        for (EnumFacing side : BlockUtil.getPossibleSides(pos)) {\r\n            if (!BlockUtil.canBeClicked(pos.offset(side))) continue;\r\n            return 3;\r\n        }\r\n        return 2;\r\n    }\r\n\r\n    public static Vec3d[] getHelpingBlocks(Vec3d vec3d) {\r\n        return new Vec3d[]{new Vec3d(vec3d.x, vec3d.y - 1.0, vec3d.z), new Vec3d(vec3d.x != 0.0 ? vec3d.x * 2.0 : vec3d.x, vec3d.y, vec3d.x != 0.0 ? vec3d.z : vec3d.z * 2.0), new Vec3d(vec3d.x == 0.0 ? vec3d.x + 1.0 : vec3d.x, vec3d.y, vec3d.x == 0.0 ? vec3d.z : vec3d.z + 1.0), new Vec3d(vec3d.x == 0.0 ? vec3d.x - 1.0 : vec3d.x, vec3d.y, vec3d.x == 0.0 ? vec3d.z : vec3d.z - 1.0), new Vec3d(vec3d.x, vec3d.y + 1.0, vec3d.z)};\r\n    }\r\n\r\n\r\n    public static List<BlockPos> getSphere(BlockPos pos, float r, int h, boolean hollow, boolean sphere, int plus_y) {\r\n        ArrayList<BlockPos> circleblocks = new ArrayList<>();\r\n        int cx = pos.getX();\r\n        int cy = pos.getY();\r\n        int cz = pos.getZ();\r\n        int x = cx - (int) r;\r\n        while ((float) x <= (float) cx + r) {\r\n            int z = cz - (int) r;\r\n            while ((float) z <= (float) cz + r) {\r\n                int y = sphere ? cy - (int) r : cy;\r\n                while (true) {\r\n                    float f = y;\r\n                    float f2 = sphere ? (float) cy + r : (float) (cy + h);\r\n                    if (!(f < f2)) break;\r\n                    double dist = (cx - x) * (cx - x) + (cz - z) * (cz - z) + (sphere ? (cy - y) * (cy - y) : 0);\r\n                    if (dist < (double) (r * r) && (!hollow || dist >= (double) ((r - 1.0f) * (r - 1.0f)))) {\r\n                        BlockPos l = new BlockPos(x, y + plus_y, z);\r\n                        circleblocks.add(l);\r\n                    }\r\n                    ++y;\r\n                }\r\n                ++z;\r\n            }\r\n            ++x;\r\n        }\r\n        return circleblocks;\r\n    }\r\n    public static boolean canBeClicked(BlockPos pos) {\r\n        return BlockUtil.getBlock(pos).canCollideCheck(BlockUtil.getState(pos), false);\r\n    }\r\n\r\n    private static Block getBlock(BlockPos pos) {\r\n        return BlockUtil.getState(pos).getBlock();\r\n    }\r\n\r\n    private static IBlockState getState(BlockPos pos) {\r\n        return mc.world.getBlockState(pos);\r\n    }\r\n\r\n\r\n    public static BlockPos[] toBlockPos(Vec3d[] vec3ds) {\r\n        BlockPos[] list = new BlockPos[vec3ds.length];\r\n        for (int i = 0; i < vec3ds.length; ++i) {\r\n            list[i] = new BlockPos(vec3ds[i]);\r\n        }\r\n        return list;\r\n    }\r\n\r\n    public static boolean rayTracePlaceCheck(BlockPos pos, boolean shouldCheck, float height) {\r\n        return !shouldCheck || mc.world.rayTraceBlocks(new Vec3d(mc.player.posX, mc.player.posY + (double) mc.player.getEyeHeight(), mc.player.posZ), new Vec3d(pos.getX(), (float) pos.getY() + height, pos.getZ()), false, true, false) == null;\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Client-2.0.0-github/Client-2.0.0/src/main/java/client/util/BlockUtil.java	(revision 39d2239e4afec5f60e16cc39bd43c031a1396cff)
+++ Client-2.0.0-github/Client-2.0.0/src/main/java/client/util/BlockUtil.java	(date 1630739921662)
@@ -16,6 +16,7 @@
 import net.minecraft.util.EnumHand;
 import net.minecraft.util.NonNullList;
 import net.minecraft.util.math.*;
+import net.minecraft.world.World;
 
 import java.util.*;
 import java.util.stream.Collectors;
@@ -119,6 +120,7 @@
         return block.getBlockHardness(blockState, BlockUtil.mc.world, pos) != -1.0f;
     }
 
+
     public static EntityPlayer getTarget(final float range) {
         EntityPlayer currentTarget = null;
         for (final EntityPlayer player : mc.world.playerEntities) {
Index: Client-2.0.0-github/Client-2.0.0/src/main/java/client/modules/player/Speedmine.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package client.modules.player;\r\n\r\nimport client.Client;\r\nimport client.events.BlockEvent;\r\nimport client.events.Render3DEvent;\r\nimport client.modules.Module;\r\nimport client.gui.impl.setting.Setting;\r\nimport client.util.BlockUtil;\r\nimport client.util.RenderUtil;\r\nimport client.util.Timer;\r\nimport net.minecraft.block.state.IBlockState;\r\nimport net.minecraft.init.Blocks;\r\nimport net.minecraft.network.play.client.CPacketPlayerDigging;\r\nimport net.minecraft.util.EnumHand;\r\nimport net.minecraft.util.math.BlockPos;\r\nimport net.minecraftforge.fml.common.eventhandler.SubscribeEvent;\r\n\r\nimport java.awt.*;\r\n\r\npublic class Speedmine extends Module {\r\n    private static Speedmine INSTANCE = new Speedmine();\r\n    private final Timer timer = new Timer();\r\n    public Setting<Mode> mode = this.register(new Setting(\"Mode\", Mode.PACKET));\r\n    public Setting<Boolean> render = this.register(new Setting(\"Render\", false));\r\n    public Setting<Boolean> box = this.register(new Setting(\"Box\", false, v -> this.render.getCurrentState()));\r\n    private final Setting<Integer> boxAlpha = this.register(new Setting(\"BoxAlpha\", 85, 0, 255, v -> box.getCurrentState( ) && render.getCurrentState( ) ));\r\n    public Setting<Boolean> outline = this.register(new Setting(\"Outline\", true, v -> this.render.getCurrentState()));\r\n    private final Setting<Float> lineWidth = this.register(new Setting(\"Width\", 1.0f, 0.1f, 5.0f, v -> outline.getCurrentState( ) && render.getCurrentState( ) ));\r\n    public BlockPos currentPos;\r\n    public IBlockState currentBlockState;\r\n\r\n    public Speedmine() {\r\n        super(\"Speedmine\", \"Speeds up mining and tweaks.\", Category.PLAYER);\r\n        this.setInstance();\r\n    }\r\n\r\n    public static Speedmine getInstance() {\r\n        if (INSTANCE == null) {\r\n            INSTANCE = new Speedmine();\r\n        }\r\n        return INSTANCE;\r\n    }\r\n\r\n    private void setInstance() {\r\n        INSTANCE = this;\r\n    }\r\n\r\n    @Override\r\n    public void onTick() {\r\n        if (this.currentPos != null) {\r\n            if (!Speedmine.mc.world.getBlockState(this.currentPos).equals(this.currentBlockState) || Speedmine.mc.world.getBlockState(this.currentPos).getBlock() == Blocks.AIR) {\r\n                this.currentPos = null;\r\n                this.currentBlockState = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onUpdate() {\r\n        if (Speedmine.fullNullCheck()) {\r\n            return;\r\n        }\r\n        Speedmine.mc.playerController.blockHitDelay = 0;\r\n    }\r\n\r\n    @Override\r\n    public void onRender3D(Render3DEvent event) {\r\n        if (this.render.getCurrentState() && this.currentPos != null && this.currentBlockState.getBlock() == Blocks.OBSIDIAN) {\r\n            Color color = new Color(this.timer.passedMs((int) (2000.0f * Client.serverManager.getTpsFactor())) ? 0 : 255, this.timer.passedMs((int) (2000.0f * Client.serverManager.getTpsFactor())) ? 255 : 0, 0, 255);\r\n            RenderUtil.drawBoxESP(this.currentPos, color, false, color, this.lineWidth.getCurrentState(), this.outline.getCurrentState(), this.box.getCurrentState(), this.boxAlpha.getCurrentState(), false);\r\n        }\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public void onBlockEvent(BlockEvent event) {\r\n        if (Speedmine.fullNullCheck()) {\r\n            return;\r\n        }\r\n        if (event.getStage() == 3 && Speedmine.mc.playerController.curBlockDamageMP > 0.1f) {\r\n            Speedmine.mc.playerController.isHittingBlock = true;\r\n        }\r\n        if (event.getStage() == 4) {\r\n            if (BlockUtil.canBreak(event.pos)) {\r\n                Speedmine.mc.playerController.isHittingBlock = false;\r\n                switch (this.mode.getCurrentState()) {\r\n                    case PACKET: {\r\n                        if (this.currentPos == null) {\r\n                            this.currentPos = event.pos;\r\n                            this.currentBlockState = Speedmine.mc.world.getBlockState(this.currentPos);\r\n                            this.timer.reset();\r\n                        }\r\n                        Speedmine.mc.player.swingArm(EnumHand.MAIN_HAND);\r\n                        Speedmine.mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.pos, event.facing));\r\n                        Speedmine.mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.pos, event.facing));\r\n                        event.setCanceled(true);\r\n                        break;\r\n                    }\r\n                    case INSTANT: {\r\n                        Speedmine.mc.player.swingArm(EnumHand.MAIN_HAND);\r\n                        Speedmine.mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, event.pos, event.facing));\r\n                        Speedmine.mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, event.pos, event.facing));\r\n                        Speedmine.mc.playerController.onPlayerDestroyBlock(event.pos);\r\n                        Speedmine.mc.world.setBlockToAir(event.pos);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String hudInfoString() {\r\n        return this.mode.currentEnumName();\r\n    }\r\n\r\n    public enum Mode {\r\n        PACKET,\r\n        INSTANT\r\n\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Client-2.0.0-github/Client-2.0.0/src/main/java/client/modules/player/Speedmine.java	(revision 39d2239e4afec5f60e16cc39bd43c031a1396cff)
+++ Client-2.0.0-github/Client-2.0.0/src/main/java/client/modules/player/Speedmine.java	(date 1630740325516)
@@ -5,7 +5,9 @@
 import client.events.Render3DEvent;
 import client.modules.Module;
 import client.gui.impl.setting.Setting;
+import client.modules.visual.Chams;
 import client.util.BlockUtil;
+import client.util.ColorUtil;
 import client.util.RenderUtil;
 import client.util.Timer;
 import net.minecraft.block.state.IBlockState;
@@ -19,15 +21,18 @@
 
 public class Speedmine extends Module {
     private static Speedmine INSTANCE = new Speedmine();
-    private final Timer timer = new Timer();
-    public Setting<Mode> mode = this.register(new Setting("Mode", Mode.PACKET));
+    Timer timer = new Timer();
+    int increasingAlpha;
+    public Setting<Mode> mode = register(new Setting("Mode", Mode.PACKET));
     public Setting<Boolean> render = this.register(new Setting("Render", false));
-    public Setting<Boolean> box = this.register(new Setting("Box", false, v -> this.render.getCurrentState()));
-    private final Setting<Integer> boxAlpha = this.register(new Setting("BoxAlpha", 85, 0, 255, v -> box.getCurrentState( ) && render.getCurrentState( ) ));
-    public Setting<Boolean> outline = this.register(new Setting("Outline", true, v -> this.render.getCurrentState()));
-    private final Setting<Float> lineWidth = this.register(new Setting("Width", 1.0f, 0.1f, 5.0f, v -> outline.getCurrentState( ) && render.getCurrentState( ) ));
-    public BlockPos currentPos;
-    public IBlockState currentBlockState;
+    public Setting<Integer> red = register(new Setting<>("Red", 255, 0, 255));
+    public Setting<Integer> green = register(new Setting<>("Green", 255, 0, 255));
+    public Setting<Integer> blue = register(new Setting<>("Blue", 255, 0, 255));
+    public Setting<Float> alpha = register(new Setting<>("Alpha", 50.0f, 0.1f, 255.0f));
+
+    public Setting<Float> lineWidth = this.register(new Setting("Width", 1.0f, 0.1f, 5.0f));
+    BlockPos currentPos;
+    IBlockState currentBlockState;
 
     public Speedmine() {
         super("Speedmine", "Speeds up mining and tweaks.", Category.PLAYER);
@@ -53,6 +58,9 @@
                 this.currentBlockState = null;
             }
         }
+        if(increasingAlpha < alpha.getCurrentState()){
+            ++increasingAlpha;
+        }
     }
 
     @Override
@@ -66,8 +74,9 @@
     @Override
     public void onRender3D(Render3DEvent event) {
         if (this.render.getCurrentState() && this.currentPos != null && this.currentBlockState.getBlock() == Blocks.OBSIDIAN) {
-            Color color = new Color(this.timer.passedMs((int) (2000.0f * Client.serverManager.getTpsFactor())) ? 0 : 255, this.timer.passedMs((int) (2000.0f * Client.serverManager.getTpsFactor())) ? 255 : 0, 0, 255);
-            RenderUtil.drawBoxESP(this.currentPos, color, false, color, this.lineWidth.getCurrentState(), this.outline.getCurrentState(), this.box.getCurrentState(), this.boxAlpha.getCurrentState(), false);
+           increasingAlpha = 0;
+           Color color = new Color(ColorUtil.toRGBA(red.getCurrentState(), green.getCurrentState(), blue.getCurrentState(), increasingAlpha));
+           RenderUtil.drawBoxESP(this.currentPos, color, false, color, this.lineWidth.getCurrentState(), true, true, increasingAlpha, false);
         }
     }
 
