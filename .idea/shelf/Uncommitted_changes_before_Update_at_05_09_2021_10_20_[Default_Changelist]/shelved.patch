Index: Client-2.0.0-github/Client-2.0.0/src/main/java/client/modules/visual/PopChams.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package client.modules.visual;\r\n\r\nimport client.events.NewPopEvent;\r\nimport client.gui.impl.setting.Setting;\r\nimport client.modules.Module;\r\nimport net.minecraft.client.renderer.OpenGlHelper;\r\nimport net.minecraft.entity.player.EntityPlayer;\r\nimport net.minecraftforge.fml.common.eventhandler.SubscribeEvent;\r\nimport net.minecraft.entity.Entity;\r\nimport org.lwjgl.opengl.GL11;\r\nimport java.util.Map;\r\nimport net.minecraftforge.client.event.RenderWorldLastEvent;\r\nimport net.minecraft.client.entity.EntityOtherPlayerMP;\r\nimport java.util.HashMap;\r\n\r\npublic class PopChams extends Module {\r\n    public Setting<Float> fadeTime = register(new Setting<>(\"FadeTime\", 3000.0f, 1.0f, 5000.0f));\r\n\r\n    private final HashMap<EntityOtherPlayerMP, Long> popFakePlayerMap;\r\n\r\n    public PopChams() {\r\n        super(\"PopChams\", \"Draws fake entities when someone pops.\", Category.VISUAL);\r\n        this.popFakePlayerMap = new HashMap<>();\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public void onRenderLast(final RenderWorldLastEvent event) {\r\n        for (final Map.Entry<EntityOtherPlayerMP, Long> entry : new HashMap<>(this.popFakePlayerMap).entrySet()) {\r\n            if (System.currentTimeMillis() - entry.getValue() > (long)fadeTime.getCurrentState().floatValue()) {\r\n                this.popFakePlayerMap.remove(entry.getKey());\r\n            }\r\n            else {\r\n                GL11.glPushMatrix();\r\n                GL11.glDepthRange(0.0, 0.01);\r\n                GL11.glDisable(2896);\r\n                GL11.glDisable(3553);\r\n                GL11.glPolygonMode(1032, 6913);\r\n                GL11.glEnable(3008);\r\n                GL11.glEnable(3042);\r\n                GL11.glEnable(2848);\r\n                GL11.glHint(3154, 4354);\r\n                this.renderEntity(entry.getKey(), event.getPartialTicks(), false);\r\n                GL11.glHint(3154, 4352);\r\n                GL11.glPolygonMode(1032, 6914);\r\n                GL11.glEnable(2896);\r\n                GL11.glDepthRange(0.0, 1.0);\r\n                GL11.glEnable(3553);\r\n                GL11.glPopMatrix();\r\n            }\r\n        }\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public void onPop(final NewPopEvent event) {\r\n        if (mc.world.getEntityByID(event.getEntityId()) != null) {\r\n            final Entity entity = mc.world.getEntityByID(event.getEntityId());\r\n            if (entity instanceof EntityPlayer) {\r\n                final EntityPlayer player = (EntityPlayer)entity;\r\n                final EntityOtherPlayerMP fakeEntity = new EntityOtherPlayerMP(mc.world, player.getGameProfile());\r\n                fakeEntity.copyLocationAndAnglesFrom(player);\r\n                fakeEntity.rotationYawHead = player.rotationYawHead;\r\n                fakeEntity.prevRotationYawHead = player.rotationYawHead;\r\n                fakeEntity.rotationYaw = player.rotationYaw;\r\n                fakeEntity.prevRotationYaw = player.rotationYaw;\r\n                fakeEntity.rotationPitch = player.rotationPitch;\r\n                fakeEntity.prevRotationPitch = player.rotationPitch;\r\n                fakeEntity.cameraYaw = fakeEntity.rotationYaw;\r\n                fakeEntity.cameraPitch = fakeEntity.rotationPitch;\r\n                this.popFakePlayerMap.put(fakeEntity, System.currentTimeMillis());\r\n            }\r\n        }\r\n    }\r\n\r\n    public void renderEntity(final Entity entityIn, final float partialTicks, final boolean p_188388_3_) {\r\n        if (entityIn.ticksExisted == 0) {\r\n            entityIn.lastTickPosX = entityIn.posX;\r\n            entityIn.lastTickPosY = entityIn.posY;\r\n            entityIn.lastTickPosZ = entityIn.posZ;\r\n        }\r\n        final double d0 = entityIn.lastTickPosX + (entityIn.posX - entityIn.lastTickPosX) * partialTicks;\r\n        final double d2 = entityIn.lastTickPosY + (entityIn.posY - entityIn.lastTickPosY) * partialTicks;\r\n        final double d3 = entityIn.lastTickPosZ + (entityIn.posZ - entityIn.lastTickPosZ) * partialTicks;\r\n        final float f = entityIn.prevRotationYaw + (entityIn.rotationYaw - entityIn.prevRotationYaw) * partialTicks;\r\n        int i = entityIn.getBrightnessForRender();\r\n        if (entityIn.isBurning()) {\r\n            i = 15728880;\r\n        }\r\n        final int j = i % 65536;\r\n        final int k = i / 65536;\r\n        OpenGlHelper.setLightmapTextureCoords(OpenGlHelper.lightmapTexUnit, (float)j, (float)k);\r\n        mc.getRenderManager().renderEntity(entityIn, d0 - mc.getRenderManager().viewerPosX, d2 - mc.getRenderManager().viewerPosY, d3 - mc.getRenderManager().viewerPosZ, f, partialTicks, p_188388_3_);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Client-2.0.0-github/Client-2.0.0/src/main/java/client/modules/visual/PopChams.java	(revision 630dfe4a8354df5a9abf116706c9f0a347806736)
+++ Client-2.0.0-github/Client-2.0.0/src/main/java/client/modules/visual/PopChams.java	(date 1630830014644)
@@ -1,8 +1,12 @@
 package client.modules.visual;
 
+import client.Client;
 import client.events.NewPopEvent;
 import client.gui.impl.setting.Setting;
 import client.modules.Module;
+import client.util.ColorUtil;
+import net.minecraft.client.Minecraft;
+import net.minecraft.client.renderer.GlStateManager;
 import net.minecraft.client.renderer.OpenGlHelper;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
@@ -13,7 +17,16 @@
 import net.minecraft.client.entity.EntityOtherPlayerMP;
 import java.util.HashMap;
 
+import static org.lwjgl.opengl.GL11.glEnable;
+
 public class PopChams extends Module {
+
+    float red;
+
+    float green;
+
+    float blue;
+
     public Setting<Float> fadeTime = register(new Setting<>("FadeTime", 3000.0f, 1.0f, 5000.0f));
 
     private final HashMap<EntityOtherPlayerMP, Long> popFakePlayerMap;
@@ -39,7 +52,7 @@
                 GL11.glEnable(3042);
                 GL11.glEnable(2848);
                 GL11.glHint(3154, 4354);
-                this.renderEntity(entry.getKey(), event.getPartialTicks(), false);
+                renderEntity(entry.getKey(), event.getPartialTicks(), false);
                 GL11.glHint(3154, 4352);
                 GL11.glPolygonMode(1032, 6914);
                 GL11.glEnable(2896);
Index: Client-2.0.0-github/Client-2.0.0/src/main/java/client/modules/combat/AutoCrystal.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package client.modules.combat;\r\n\r\nimport client.events.PacketEvent;\r\nimport client.events.Render3DEvent;\r\nimport client.modules.Module;\r\nimport client.modules.client.ClickGui;\r\nimport client.gui.impl.setting.Setting;\r\nimport client.util.Timer;\r\nimport client.util.*;\r\nimport net.minecraft.entity.Entity;\r\nimport net.minecraft.entity.item.EntityEnderCrystal;\r\nimport net.minecraft.entity.player.EntityPlayer;\r\nimport net.minecraft.init.Items;\r\nimport net.minecraft.init.SoundEvents;\r\nimport net.minecraft.item.ItemEndCrystal;\r\nimport net.minecraft.network.play.client.CPacketHeldItemChange;\r\nimport net.minecraft.network.play.client.CPacketPlayerTryUseItemOnBlock;\r\nimport net.minecraft.network.play.client.CPacketUseEntity;\r\nimport net.minecraft.network.play.server.SPacketSoundEffect;\r\nimport net.minecraft.network.play.server.SPacketSpawnObject;\r\nimport net.minecraft.util.EnumFacing;\r\nimport net.minecraft.util.EnumHand;\r\nimport net.minecraft.util.SoundCategory;\r\nimport net.minecraft.util.math.AxisAlignedBB;\r\nimport net.minecraft.util.math.BlockPos;\r\nimport net.minecraftforge.fml.common.eventhandler.SubscribeEvent;\r\n\r\nimport java.awt.*;\r\nimport java.util.List;\r\nimport java.util.*;\r\n\r\npublic class AutoCrystal extends Module {\r\n    public Setting<Settings> setting;\r\n    public enum Settings{AUTOCRYSTAL, RENDER}\r\n    public Setting<SpeedFactor> speedFactor;\r\n    public enum SpeedFactor {TICK, UPDATE}\r\n    public Setting<CalcMode> calcMode;\r\n    public enum CalcMode{NORMAL, AUTO}\r\n    public Setting<Boolean> doBreak;\r\n    public Setting<Boolean> doPlace;\r\n    public Setting<Float> targetRange;\r\n    public Setting<Boolean> cancel;\r\n    public Setting<Float> breakRange;\r\n    public Setting<Float> breakWallRange;\r\n    public Setting<Integer> breakDelay;\r\n    public Setting<Boolean> instant;\r\n    public Setting<Float> placeRange;\r\n    public Setting<Float> placeRangeWall;\r\n    public Setting<Integer> armorPercent;\r\n    public Setting<Float> facePlaceHP;\r\n    public Setting<Float> minDamage;\r\n    public Setting<Float> maxSelfDamage;\r\n    public Setting<Boolean> swing;\r\n    public Setting<Boolean> announceOnly;\r\n    public Setting<Boolean> text;\r\n    public Setting<Boolean> box;\r\n    public Setting<RenderMode> renderMode;\r\n    public enum RenderMode{NORMAL, FADE, GLIDE}\r\n    public Setting<Float> accel;\r\n    public Setting<Float> moveSpeed;\r\n    public Setting<Enum> fade;\r\n    public enum Enum{FAST, MEDIUM, SLOW}\r\n    public Setting<Integer> red;\r\n    public Setting<Integer> green;\r\n    public Setting<Integer> blue;\r\n    public Setting<Integer> alpha;\r\n    public Setting<Boolean> rainbow;\r\n    public Setting<Boolean> outline;\r\n    public Setting<Integer> cRed;\r\n    public Setting<Integer> cGreen;\r\n    public Setting<Integer> cBlue;\r\n    public Setting<Integer> cAlpha;\r\n    public Setting<Integer> lineWidth;\r\n    public Setting<Boolean> cRainbow;\r\n    public Setting<Boolean> silentSwitch;\r\n    public Set<BlockPos> placeSet;\r\n    public  BlockPos placePos = null;\r\n    public Timer clearTimer;\r\n    public Timer breakTimer;\r\n    public int predictedId;\r\n    public BlockPos renderPos;\r\n    public BlockPos pos2;\r\n    public EntityPlayer target;\r\n    public boolean offhand;\r\n    public boolean mainhand;\r\n    public static AutoCrystal INSTANCE;\r\n    private final ArrayList<RenderPos> renderMap = new ArrayList<>();\r\n    private final ArrayList<BlockPos> currentTargets = new ArrayList<>();\r\n    private BlockPos lastRenderPos;\r\n    private AxisAlignedBB renderBB;\r\n    private float timePassed;\r\n\r\n    public AutoCrystal() {\r\n        super(\"AutoCrystal\", \"Automatically places/breaks crystals to deal damage to opponents.\", Category.COMBAT);\r\n        this.setting = (Setting<Settings>)this.register(new Setting<>(\"Setting\", Settings.AUTOCRYSTAL));\r\n        this.speedFactor = (Setting<SpeedFactor>)this.register(new Setting<>(\"SpeedFactor\", SpeedFactor.UPDATE, v-> setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.calcMode = (Setting<CalcMode>)this.register(new Setting<>(\"CalcMode\", CalcMode.NORMAL, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.doPlace = (Setting<Boolean>)this.register(new Setting(\"Place\", true, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.doBreak = (Setting<Boolean>)this.register(new Setting(\"Break\", true, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.breakRange = (Setting<Float>)this.register(new Setting(\"BreakRange\", 5.0f, 1.0f, 6.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.placeRange = (Setting<Float>)this.register(new Setting(\"PlaceRange\", 5.0f, 1.0f, 6.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.targetRange = (Setting<Float>)this.register(new Setting(\"TargetRange\",9.0f, 1.0f, 15.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.breakWallRange = (Setting<Float>)this.register(new Setting(\"BreakRangeWall\", 5.0f, 1.0f, 6.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.placeRangeWall = (Setting<Float>)this.register(new Setting(\"PlaceRangeWall\", 5.0f, 1.0f, 6.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.breakDelay = (Setting<Integer>)this.register(new Setting(\"BreakDelay\", 0, 0, 200, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.instant = (Setting<Boolean>)this.register(new Setting(\"Predict\", false, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.cancel = (Setting<Boolean>)this.register(new Setting(\"Cancel\", true, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.armorPercent = (Setting<Integer>)this.register(new Setting(\"Armor%\", 10, 0, 100, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.facePlaceHP = (Setting<Float>)this.register(new Setting(\"FaceplaceHP\", 8.0f, 0.0f, 36.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.minDamage = (Setting<Float>)this.register(new Setting(\"MinDamage\", 4.0f, 1.0f, 36.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.maxSelfDamage = (Setting<Float>)this.register(new Setting(\"MaxSelfDmg\",8.0f, 1.0f, 36.0f, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.silentSwitch = (Setting<Boolean>)this.register(new Setting(\"SilentSwitch\",true, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.swing = (Setting<Boolean>)this.register(new Setting(\"Swing\", false, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.announceOnly = (Setting<Boolean>)this.register(new Setting(\"AnnounceOnly\", false, v-> this.setting.getCurrentState() == Settings.AUTOCRYSTAL));\r\n        this.renderMode = (Setting<RenderMode>)this.register(new Setting<>(\"RenderMode\", RenderMode.NORMAL, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.box = (Setting<Boolean>)this.register(new Setting<>(\"Box\", true, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.fade = (Setting<Enum>)this.register(new Setting<>(\"Fade\", Enum.FAST, v-> this.setting.getCurrentState() == Settings.RENDER && renderMode.getCurrentState() == RenderMode.FADE));\r\n        this.accel = (Setting<Float>) this.register(new Setting<>(\"Deceleration\" , 0.8f , 0.0f, 1.0f, v-> this.setting.getCurrentState() == Settings.RENDER && renderMode.getCurrentState() == RenderMode.GLIDE));\r\n        this.moveSpeed = (Setting<Float>) this.register(new Setting<>(\"Speed\" , 900.0f , 0.0f, 1500.0f, v-> this.setting.getCurrentState() == Settings.RENDER && renderMode.getCurrentState() == RenderMode.GLIDE));\r\n        this.red = (Setting<Integer>)this.register(new Setting<>(\"BoxRed\", 255, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.green = (Setting<Integer>)this.register(new Setting<>(\"BoxGreen\", 255, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.blue = (Setting<Integer>)this.register(new Setting<>(\"BoxBlue\", 255, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.alpha = (Setting<Integer>)this.register(new Setting<>(\"BoxAlpha\", 120, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.rainbow = (Setting<Boolean>)this.register(new Setting<>(\"BoxRainbow\", true, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.outline = (Setting<Boolean>)this.register(new Setting<>(\"Outline\", true, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.cRed = (Setting<Integer>)this.register(new Setting<>(\"OutlineRed\", 255, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.cGreen = (Setting<Integer>)this.register(new Setting<>(\"OutlineGreen\", 255, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.cBlue = (Setting<Integer>)this.register(new Setting<>(\"OutlineBlue\", 255, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.cAlpha = (Setting<Integer>)this.register(new Setting<>(\"OutlineAlpha\", 255, 0, 255, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.lineWidth = (Setting<Integer>)this.register(new Setting<>(\"OutlineWidth\", 1, 0, 5, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.cRainbow = (Setting<Boolean>)this.register(new Setting<>(\"OutlineRainbow\", true, v-> this.setting.getCurrentState() == Settings.RENDER));\r\n        this.placeSet = new HashSet<>();\r\n        this.clearTimer = new Timer();\r\n        this.breakTimer = new Timer();\r\n        this.predictedId = -1;\r\n        this.renderPos = null;\r\n        this.pos2 = null;\r\n        this.target = null;\r\n        AutoCrystal.INSTANCE = this;\r\n    }\r\n\r\n    public static AutoCrystal getInstance() {\r\n        return AutoCrystal.INSTANCE;\r\n    }\r\n\r\n    private boolean update() {\r\n        if (fullNullCheck()) {\r\n            return false;\r\n        }\r\n        if (this.clearTimer.hasReached(500L)) {\r\n            this.placeSet.clear();\r\n            this.predictedId = -1;\r\n            this.renderPos = null;\r\n            this.clearTimer.reset();\r\n        }\r\n        this.offhand = (mc.player.getHeldItemOffhand().getItem() == Items.END_CRYSTAL);\r\n        this.mainhand = (mc.player.getHeldItemMainhand().getItem() == Items.END_CRYSTAL);\r\n        return true;\r\n    }\r\n\r\n    @Override\r\n    public void onToggle() {\r\n        this.placeSet.clear();\r\n        this.predictedId = -1;\r\n        this.renderPos = null;\r\n    }\r\n\r\n    @Override\r\n    public void onUpdate() {\r\n        if (!this.update()) {\r\n            return;\r\n        }\r\n        this.target = EntityUtil.getTarget(this.targetRange.getCurrentState());\r\n        if (this.target == null) {\r\n            return;\r\n        }\r\n        if (speedFactor.getCurrentState() == SpeedFactor.UPDATE && !announceOnly.getCurrentState()) {\r\n            if(doPlace.getCurrentState()) {\r\n                this.doPlace();\r\n            }\r\n            if(doBreak.getCurrentState()) {\r\n                this.doBreak();\r\n            }\r\n        }\r\n    }\r\n    public void onDisable(){\r\n        this.lastRenderPos = null;\r\n    }\r\n    @Override\r\n    public void onTick() {\r\n        if (speedFactor.getCurrentState() == SpeedFactor.TICK && !announceOnly.getCurrentState()) {\r\n            if(doPlace.getCurrentState()) {\r\n                this.doPlace();\r\n            }\r\n            if(doBreak.getCurrentState()) {\r\n                this.doBreak();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    private void doPlace() {\r\n        final List<BlockPos> sphere = BlockUtil.getSphere(this.placeRange.getCurrentState(), true);\r\n        for (int size = sphere.size(), i = 0; i < size; ++i) {\r\n            final BlockPos pos = sphere.get(i);\r\n            final float self = this.calculate(pos, mc.player);\r\n            if (BlockUtil.canPlaceCrystal(pos, true)) {\r\n                final float damage;\r\n                if (calcMode.getCurrentState() == CalcMode.NORMAL) {\r\n                    if (EntityUtil.getHealth(mc.player) > self + 0.5f && self < maxSelfDamage.getCurrentState() && (damage = this.calculate(pos, this.target)) > minDamage.getCurrentState()) {\r\n                        if (damage <= this.minDamage.getCurrentState()) {\r\n                            if (this.facePlaceHP.getCurrentState() <= EntityUtil.getHealth(this.target) && !PlayerUtil.isArmorLow(this.target, this.armorPercent.getCurrentState())) {\r\n                                continue;\r\n                            }\r\n                            if (damage <= 2.0f) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        placePos = pos;\r\n                        pos2 = placePos;\r\n                        currentTargets.clear();\r\n                        currentTargets.add(pos);\r\n                    }\r\n                } else if (calcMode.getCurrentState() == CalcMode.AUTO) {\r\n                    if ((damage = this.calculate(pos, this.target)) > self && damage > minDamage.getCurrentState() && self < maxSelfDamage.getCurrentState()) {\r\n                        if (damage <= this.minDamage.getCurrentState()) {\r\n                            if (this.facePlaceHP.getCurrentState() <= EntityUtil.getHealth(this.target) && !PlayerUtil.isArmorLow(this.target, this.armorPercent.getCurrentState())) {\r\n                                continue;\r\n                            }\r\n                            if (damage <= 2.0f) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        placePos = pos;\r\n                        pos2 = placePos;\r\n                        currentTargets.clear();\r\n                        currentTargets.add(pos);\r\n                    }\r\n                } {\r\n\r\n                }\r\n            }\r\n\r\n        }\r\n        if (silentSwitch.getCurrentState() && (InventoryUtil.findHotbarBlock(ItemEndCrystal.class) > 1)) {\r\n            mc.player.connection.sendPacket(new CPacketHeldItemChange(InventoryUtil.findHotbarBlock(ItemEndCrystal.class)));\r\n        }\r\n\r\n        if (!this.offhand && !this.mainhand) {\r\n            this.renderPos = null;\r\n            return;\r\n        }\r\n\r\n        if (placePos != null) {\r\n            clearMap(placePos);\r\n            Objects.requireNonNull(mc.getConnection()).sendPacket(new CPacketPlayerTryUseItemOnBlock(placePos, EnumFacing.UP, this.offhand ? EnumHand.OFF_HAND : EnumHand.MAIN_HAND , 0.5f, 0.5f, 0.5f));\r\n            renderMap.add(new RenderPos(placePos, 0.0));\r\n            this.placeSet.add(placePos);\r\n            this.renderPos = placePos;\r\n        } else {\r\n            this.renderPos = null;\r\n        }\r\n        if (silentSwitch.getCurrentState()) {\r\n            int oldSlot = mc.player.inventory.currentItem;\r\n            mc.player.connection.sendPacket(new CPacketHeldItemChange(oldSlot));\r\n        }\r\n    }\r\n\r\n    private void doBreak() {\r\n        Entity entity = null;\r\n        for (int size = mc.world.loadedEntityList.size(), i = 0; i < size; ++i) {\r\n            final Entity crystal = mc.world.loadedEntityList.get(i);\r\n            if (crystal.getClass() == EntityEnderCrystal.class && this.isValid(crystal)) {\r\n                if (crystal.getEntityId() != this.predictedId) {\r\n                    final float self = this.calculate(crystal, mc.player);\r\n                    final float damage;\r\n                    if (EntityUtil.getHealth(mc.player) > self + 0.5f && (damage = this.calculate(crystal, this.target)) > self && damage > self) {\r\n                        if (damage <= this.minDamage.getCurrentState()) {\r\n                            if (this.facePlaceHP.getCurrentState() <= EntityUtil.getHealth(this.target) && !PlayerUtil.isArmorLow(this.target, this.armorPercent.getCurrentState())) {\r\n                                continue;\r\n                            }\r\n                            if (damage <= 2.0f) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        entity = crystal;\r\n                    }\r\n                }\r\n            }\r\n            if (entity != null && this.breakTimer.passedMs(this.breakDelay.getCurrentState())) {\r\n                BlockPos renderPos = entity.getPosition().down();\r\n                clearMap(renderPos);\r\n                Objects.requireNonNull(mc.getConnection()).sendPacket(new CPacketUseEntity(entity));\r\n                renderMap.add(new RenderPos(renderPos, 0.0));\r\n                if(swing.getCurrentState()) {\r\n                    mc.player.swingArm(this.offhand ? EnumHand.OFF_HAND : EnumHand.MAIN_HAND);\r\n                }\r\n                this.breakTimer.reset();\r\n            }\r\n        }\r\n    }\r\n\r\n    private boolean isValid(final Entity crystal) {\r\n        return (mc.player.canEntityBeSeen(crystal) ? (this.breakRange.getCurrentState() * this.breakRange.getCurrentState()) : (this.breakWallRange.getCurrentState() * this.breakWallRange.getCurrentState())) > mc.player.getDistanceSq(crystal);\r\n    }\r\n\r\n    private float calculate(final Entity crystal, final EntityPlayer target) {\r\n        return EntityUtil.calculate(crystal.posX, crystal.posY, crystal.posZ, target);\r\n    }\r\n\r\n    private float calculate(final BlockPos pos, final EntityPlayer entity) {\r\n        return EntityUtil.calculate(pos.getX() + 0.5f, pos.getY() + 1, pos.getZ() + 0.5f, entity);\r\n    }\r\n\r\n    public void instantHit(final int id) {\r\n        final CPacketUseEntity hitPacket = new CPacketUseEntity();\r\n        hitPacket.entityId = id;\r\n        hitPacket.action = CPacketUseEntity.Action.ATTACK;\r\n        Objects.requireNonNull(mc.getConnection()).sendPacket(hitPacket);\r\n        this.predictedId = id;\r\n        if(swing.getCurrentState()) {\r\n            mc.player.swingArm(this.offhand ? EnumHand.OFF_HAND : EnumHand.MAIN_HAND);\r\n        }\r\n    }\r\n\r\n    @SubscribeEvent\r\n    public void onPacketReceive(final PacketEvent.Receive event) {\r\n        if (event.getPacket() instanceof SPacketSpawnObject && this.instant.getCurrentState()) {\r\n            final Object packet = event.getPacket();\r\n            final BlockPos pos = new BlockPos(((SPacketSpawnObject)packet).getX(), ((SPacketSpawnObject)packet).getY(), ((SPacketSpawnObject)packet).getZ());\r\n            if (((SPacketSpawnObject)packet).getType() == 51 && this.placeSet.contains(pos.down())) {\r\n                if (mc.player.getDistance(pos.getX(), pos.getY(), pos.getZ()) > this.breakRange.getCurrentState()) {\r\n                    return;\r\n                }\r\n                this.instantHit(((SPacketSpawnObject)packet).getEntityID());\r\n            }\r\n        }\r\n        Object packet;\r\n        if (event.getPacket() instanceof SPacketSoundEffect && this.cancel.getCurrentState() && ((SPacketSoundEffect)(packet = event.getPacket())).getCategory() == SoundCategory.BLOCKS && ((SPacketSoundEffect)packet).getSound() == SoundEvents.ENTITY_GENERIC_EXPLODE) {\r\n            final ArrayList<Entity> entities = new ArrayList<>(mc.world.loadedEntityList);\r\n            for (int size = entities.size(), i = 0; i < size; ++i) {\r\n                final Entity entity = entities.get(i);\r\n                if (entity instanceof EntityEnderCrystal) {\r\n                    if (entity.getDistanceSq(((SPacketSoundEffect)packet).getX(), ((SPacketSoundEffect)packet).getY(), ((SPacketSoundEffect)packet).getZ()) < 36.0) {\r\n                        entity.setDead();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void onRender3D(Render3DEvent event) {\r\n\r\n        if (renderMap.isEmpty()) return;\r\n        List<RenderPos> toRemove = new ArrayList<>();\r\n        for (Iterator<RenderPos> it = renderMap.iterator(); it.hasNext(); ) {\r\n            RenderPos renderPos = it.next();\r\n            Color color;\r\n            Color color2;\r\n            color = new Color(red.getCurrentState(), green.getCurrentState(), blue.getCurrentState(), (int) Math.max(alpha.getCurrentState() - renderPos.alpha, 0));\r\n            color2 = new Color(cRed.getCurrentState(), cGreen.getCurrentState(), cBlue.getCurrentState(), (int) Math.max(cAlpha.getCurrentState() - renderPos.alpha, 0));\r\n            if(renderMode.getCurrentState() == RenderMode.NORMAL || renderMode.getCurrentState() == RenderMode.FADE) {\r\n                RenderUtil.drawBoxESP(renderPos.pos, rainbow.getCurrentState() ? ColorUtil.rainbow(ClickGui.getInstance().rainbowHue.getCurrentState()) : color, this.outline.getCurrentState(), cRainbow.getCurrentState() ? ColorUtil.rainbow(ClickGui.getInstance().rainbowHue.getCurrentState()) : color2, this.lineWidth.getCurrentState(), this.outline.getCurrentState(), this.box.getCurrentState(), (int) Math.max(cAlpha.getCurrentState() - renderPos.alpha, 0), true);\r\n            }\r\n            if (renderPos.alpha > Math.max(alpha.getCurrentState(), rainbow.getCurrentState() ? ColorUtil.rainbow(ClickGui.getInstance().rainbowHue.getCurrentState()).getRGB() : ColorUtil.toRGBA(red.getCurrentState(), green.getCurrentState(), blue.getCurrentState())))\r\n                toRemove.add(renderPos);\r\n            renderPos.alpha = renderPos.alpha + (fade.getCurrentState() == Enum.FAST ? 1.5 : fade.getCurrentState() == Enum.SLOW ? 0.5 : 1);\r\n            if (currentTargets.contains(renderPos.pos)) {\r\n                renderPos.alpha = 0;\r\n            } else if (renderMode.getCurrentState() != RenderMode.FADE) {\r\n                toRemove.add(renderPos);\r\n            }\r\n        }\r\n        renderMap.removeAll(toRemove);\r\n\r\n        if (renderMode.getCurrentState() == RenderMode.GLIDE && renderPos != null) {\r\n            Color color2 = new Color(cRed.getCurrentState(), cGreen.getCurrentState(), cBlue.getCurrentState(), cAlpha.getCurrentState());\r\n            Color color = new Color(red.getCurrentState(), green.getCurrentState(), blue.getCurrentState(), alpha.getCurrentState());\r\n            if ( this.lastRenderPos == null || AutoCrystal.mc.player.getDistance (this.renderBB.minX , this.renderBB.minY , this.renderBB.minZ ) > this.placeRange.getCurrentState() ) {\r\n                this.lastRenderPos = this.renderPos;\r\n                this.renderBB = new AxisAlignedBB( this.renderPos );\r\n                this.timePassed = 0;\r\n            }\r\n            if ( !this.lastRenderPos.equals ( this.renderPos ) ) {\r\n                this.lastRenderPos = this.renderPos;\r\n                this.timePassed = 0;\r\n            }\r\n            double xDiff = this.renderPos.getX ( ) - this.renderBB.minX;\r\n            double yDiff = this.renderPos.getY ( ) - this.renderBB.minY;\r\n            double zDiff = this.renderPos.getZ ( ) - this.renderBB.minZ;\r\n            float multiplier = this.timePassed / this.moveSpeed.getCurrentState ( ) * this.accel.getCurrentState ( );\r\n            if ( multiplier > 1 ) multiplier = 1;\r\n            this.renderBB = this.renderBB.offset ( xDiff * multiplier , yDiff * multiplier , zDiff * multiplier );\r\n                RenderUtil.drawPerryESP(this.renderBB, color, color2, lineWidth.getCurrentState(), outline.getCurrentState(), box.getCurrentState(), 1.0f, 1.0f, 1.0f);\r\n            if ( this.renderBB.equals ( new AxisAlignedBB ( this.renderPos ) ) ) {\r\n                this.timePassed = 0;\r\n            } else this.timePassed += 50.0f;\r\n        }\r\n\r\n    }\r\n    static {\r\n        AutoCrystal.INSTANCE = new AutoCrystal();\r\n    }\r\n\r\n\r\n\r\n    class RenderPos {\r\n        public RenderPos(BlockPos pos, Double damage) {\r\n            this.pos = pos;\r\n            this.damage = damage;\r\n        }\r\n\r\n        Double damage;\r\n        double alpha;\r\n        BlockPos pos;\r\n    }\r\n\r\n    private void clearMap(BlockPos checkBlock) {\r\n        List<RenderPos> toRemove = new ArrayList<>();\r\n        if (checkBlock == null || renderMap.isEmpty()) return;\r\n        for (RenderPos pos : renderMap) {\r\n            if (pos.pos.getX() == checkBlock.getX() && pos.pos.getY() == checkBlock.getY() && pos.pos.getZ() == checkBlock.getZ())\r\n                toRemove.add(pos);\r\n        }\r\n        renderMap.removeAll(toRemove);\r\n    }\r\n\r\n    public String hudInfoString() {\r\n        if(target != null) {\r\n            return target.getName() + \" | \" + Math.round(target.getHealth());\r\n        }\r\n        return null;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Client-2.0.0-github/Client-2.0.0/src/main/java/client/modules/combat/AutoCrystal.java	(revision 630dfe4a8354df5a9abf116706c9f0a347806736)
+++ Client-2.0.0-github/Client-2.0.0/src/main/java/client/modules/combat/AutoCrystal.java	(date 1630828666970)
@@ -200,6 +200,7 @@
 
 
     private void doPlace() {
+        float maxDamage = 0.5f;
         final List<BlockPos> sphere = BlockUtil.getSphere(this.placeRange.getCurrentState(), true);
         for (int size = sphere.size(), i = 0; i < size; ++i) {
             final BlockPos pos = sphere.get(i);
@@ -207,7 +208,7 @@
             if (BlockUtil.canPlaceCrystal(pos, true)) {
                 final float damage;
                 if (calcMode.getCurrentState() == CalcMode.NORMAL) {
-                    if (EntityUtil.getHealth(mc.player) > self + 0.5f && self < maxSelfDamage.getCurrentState() && (damage = this.calculate(pos, this.target)) > minDamage.getCurrentState()) {
+                    if (EntityUtil.getHealth(mc.player) > self + 0.5f && this.maxSelfDamage.getCurrentState() > self && (damage = this.calculate(pos, this.target)) > maxDamage && damage > self) {
                         if (damage <= this.minDamage.getCurrentState()) {
                             if (this.facePlaceHP.getCurrentState() <= EntityUtil.getHealth(this.target) && !PlayerUtil.isArmorLow(this.target, this.armorPercent.getCurrentState())) {
                                 continue;
@@ -216,6 +217,7 @@
                                 continue;
                             }
                         }
+                        maxDamage = damage;
                         placePos = pos;
                         pos2 = placePos;
                         currentTargets.clear();
